<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analytics Pilot</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .toast {
            position: fixed;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            color: white;
            opacity: 1;
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 80%;
            margin-bottom: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .toast.info {
            background-color: #3b82f6;
        }
        .toast.success {
            background-color: #10b981;
        }
        .toast.warning {
            background-color: #1f6feb;
        }
        .toast.error {
            background-color: #ef4444;
        }
        .toast.hide {
            opacity: 0;
        }
        
        /* Update Notification Styles */
        .update-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 320px;
            z-index: 10000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: slideInRight 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: none;
        }
        
        .update-notification.show {
            display: block;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .update-notification-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .update-notification-title {
            font-size: 16px;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .update-notification-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.2s ease, background-color 0.2s ease;
        }
        
        .update-notification-close:hover {
            opacity: 1;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .update-notification-content {
            margin-bottom: 12px;
        }
        
        .update-notification-version {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 4px;
        }
        
        .update-notification-description {
            font-size: 13px;
            opacity: 0.8;
            line-height: 1.4;
        }
        
        .update-notification-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .update-notification-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .update-notification-btn.primary {
            background: white;
            color: #667eea;
        }
        
        .update-notification-btn.primary:hover {
            background: #f8f9ff;
            transform: translateY(-1px);
        }
        
        .update-notification-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .update-notification-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .update-icon {
            width: 16px;
            height: 16px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <span class="logo-text disconnected" id="dataSourceName">Connect to Power BI</span>
            </div>
                        <div class="connection-status">
                <div class="status-indicator" id="connectionStatus">
                    <span class="status-dot"></span>
                    <span class="status-text">Not Connected</span>
                </div>
                
                
                <button class="connect-btn" id="connectBtn">Connect to Power BI</button>

                <!-- Chat History Dropdown -->
                <div class="chat-history-dropdown" id="chatHistoryDropdown">
                    <button class="chat-history-btn" id="chatHistoryBtn" title="Chat History">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                    </button>
                    <div class="chat-history-menu" id="chatHistoryMenu">
                        <button class="chat-history-menu-item new-chat" id="newChatBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            New Chat
                        </button>
                        <div class="chat-history-divider"></div>
                        <div class="chat-history-list" id="chatHistoryList">
                            <!-- Chat history items will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Settings Dropdown -->
                <div class="settings-dropdown" id="settingsDropdown">
                    <button class="settings-btn" id="settingsDropdownBtn" title="Settings">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82v.07a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                        </svg>
                    </button>
                    <div class="settings-menu" id="settingsMenu">
                        <div id="modelSwitcher" style="display: none; border-bottom: 1px solid #30363d; margin-bottom: 5px; padding-bottom: 5px;">
                            <!-- Model switcher will be populated here -->
                        </div>
                        <button class="settings-menu-item" id="apiSettingsBtn" style="align-items: flex-start; padding: 14px 16px;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-top: 2px; flex-shrink: 0;">
                                <circle cx="12" cy="12" r="3"></circle>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82v0a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                            </svg>
                            <span id="apiSettingsText">API Settings</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Chat Container -->
            <div class="chat-container">
                <div class="chat-messages" id="chatMessages">
                    <!-- Initial message -->
                    <div class="message assistant-message">
                        <div class="message-avatar"></div>
                        <div class="message-content">
                            <div class="message-text">
                                Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.
                            </div>
                        </div>
                    </div>
                </div>

                <div class="chat-input-container">
                    <div class="input-wrapper">
                        <textarea 
                            class="chat-input" 
                            id="chatInput" 
                            placeholder="Type your message here..."
                            disabled
                            rows="1"
                        ></textarea>
                        <button class="send-btn" id="sendBtn" disabled>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22,2 15,22 11,13 2,9"></polygon>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Connection Modal -->
        <div class="modal" id="connectionModal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>Connect to Power BI</h3>
                    <button class="close-btn" id="closeModal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="connection-type">
                        <label>
                            <input type="radio" name="connectionType" value="powerbi" checked>
                            Power BI Desktop
                        </label>
                    </div>
                    
                    <div class="connection-details">
                        <div class="powerbi-instances" id="powerbiInstances">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <label for="instanceSelect">Available Power BI Instances:</label>
                                <button id="refreshInstancesBtn" class="refresh-btn" title="Refresh instances" style="
                                    width: 32px; 
                                    height: 32px; 
                                    padding: 6px; 
                                    background: #21262d; 
                                    border: 1px solid #30363d; 
                                    border-radius: 6px; 
                                    cursor: pointer; 
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                    transition: all 0.2s ease;
                                    color: #7d8590;
                                " onmouseover="this.style.background='#30363d'; this.style.borderColor='#58a6ff'; this.style.color='#c9d1d9'" onmouseout="this.style.background='#21262d'; this.style.borderColor='#30363d'; this.style.color='#7d8590'">
                                    <img src="../assets/refresh.png" width="16" height="16" alt="Refresh">
                                </button>
                            </div>
                            <select id="instanceSelect">
                                <option value="">Detecting instances...</option>
                            </select>
                        </div>
                        
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="cancel-btn" id="cancelConnect">Cancel</button>
                    <button class="connect-btn primary" id="confirmConnect">Connect</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Include API client for direct LLM communication -->
    <script src="./api-client.js"></script>
    
    <script>
        // Initialize the application
        let app;
        
        document.addEventListener('DOMContentLoaded', async () => {
            // Initialize API client
            await window.apiClient.loadSettings();
            
            // Check if API is configured
            if (!window.apiClient.isConfigured()) {
                showApiConfigurationPrompt();
            }
            
            // Listen for settings changes
            if (window.electronAPI && window.electronAPI.onSettingsChanged) {
                window.electronAPI.onSettingsChanged(async () => {
                    await window.apiClient.loadSettings();
                    // Hide any existing API configuration prompts if now configured
                    const existingNotification = document.getElementById('api-config-notification');
                    if (existingNotification && window.apiClient.isConfigured()) {
                        existingNotification.remove();
                    }
                    // Show prompt if no longer configured
                    if (!window.apiClient.isConfigured()) {
                        showApiConfigurationPrompt();
                    }
                    // Update settings menu text
                    updateSettingsMenuText();
                });
            }
            
            // Update settings menu text on initial load
            updateSettingsMenuText();
            
            // Initialize the main application
            initializeApp();
        });
        
        function initializeApp() {
            // Main application initialization
            app = new AnalyticsPilot();
        }
        
        const Utils = {
            showToast: function(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;
                toast.textContent = message;
                
                // Calculate position based on existing toasts
                const existingToasts = document.querySelectorAll('.toast');
                let bottomPosition = 20;
                
                existingToasts.forEach(existingToast => {
                    const rect = existingToast.getBoundingClientRect();
                    const currentBottom = window.innerHeight - rect.bottom + parseInt(getComputedStyle(existingToast).marginBottom);
                    if (currentBottom >= bottomPosition) {
                        bottomPosition = currentBottom + rect.height + 8; // 8px gap between toasts
                    }
                });
                
                toast.style.bottom = bottomPosition + 'px';
                document.body.appendChild(toast);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    toast.classList.add('hide');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            document.body.removeChild(toast);
                        }
                        // Reposition remaining toasts
                        this.repositionToasts();
                    }, 300);
                }, 3000);
            },
            
            repositionToasts: function() {
                const toasts = document.querySelectorAll('.toast:not(.hide)');
                let bottomPosition = 20;
                
                // Reposition from bottom to top
                Array.from(toasts).reverse().forEach(toast => {
                    toast.style.bottom = bottomPosition + 'px';
                    const rect = toast.getBoundingClientRect();
                    bottomPosition += rect.height + 8; // 8px gap between toasts
                });
            }
        };
        
        // Settings and API configuration functions
        function showApiConfigurationPrompt() {
            // Create a light popup notification instead of banner
            const notification = document.createElement('div');
            notification.id = 'api-config-notification';
            notification.innerHTML = `
                <div style="
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(255, 255, 255, 0.95);
                    color: #1f2937;
                    padding: 1rem 1.5rem;
                    border-radius: 8px;
                    font-weight: 500;
                    font-size: 14px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    border: 1px solid #e5e7eb;
                    z-index: 1000;
                    max-width: 350px;
                    backdrop-filter: blur(10px);
                    animation: slideInRight 0.3s ease-out;
                ">
                    <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#3b82f6" stroke-width="2" style="margin-right: 0.5rem;">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <strong>Setup Required</strong>
                    </div>
                    <div style="margin-bottom: 1rem; line-height: 1.4;">
                        Configure your API settings to start using Analytics Pilot.
                    </div>
                    <div style="display: flex; gap: 0.5rem;">
                        <button onclick="openSettings(); document.getElementById('api-config-notification').remove();" style="
                            background: #3b82f6;
                            color: white;
                            border: none;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            font-weight: 600;
                            cursor: pointer;
                            font-size: 12px;
                        ">Configure API</button>
                        <button onclick="document.getElementById('api-config-notification').remove()" style="
                            background: transparent;
                            color: #6b7280;
                            border: 1px solid #d1d5db;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            cursor: pointer;
                            font-size: 12px;
                        ">Dismiss</button>
                    </div>
                </div>
                <style>
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                </style>
            `;
            document.body.appendChild(notification);
            
            // Auto-dismiss after 10 seconds
            setTimeout(() => {
                const notif = document.getElementById('api-config-notification');
                if (notif) {
                    notif.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => notif.remove(), 300);
                }
            }, 10000);
        }
        
        function openSettings() {
            if (window.electronAPI && window.electronAPI.settings) {
                window.electronAPI.settings.open();
            } else {
                console.error('Settings API not available');
            }
        }
        
        function updateSettingsMenuText() {
            const settingsText = document.getElementById('apiSettingsText');
            if (settingsText && window.apiClient && window.apiClient.isConfigured()) {
                const configName = window.apiClient.getConfigName();
                const currentModel = window.apiClient.getCurrentModel();
                
                // Create hierarchical display with config name and model
                settingsText.innerHTML = `
                    <div style="display: flex; flex-direction: column; gap: 2px;">
                        <div style="font-weight: 500; color: #c9d1d9; font-size: 14px;">
                            ${escapeHtml(configName || 'Selected Configuration')}
                        </div>
                        ${currentModel ? `
                            <div style="font-size: 11px; color: #7d8590; line-height: 1.2;">
                                Model: ${escapeHtml(currentModel)}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                // Update model switcher
                updateModelSwitcher();
            } else if (settingsText) {
                settingsText.innerHTML = 'API Settings';
                // Hide model switcher
                const modelSwitcher = document.getElementById('modelSwitcher');
                if (modelSwitcher) {
                    modelSwitcher.style.display = 'none';
                }
            }
        }
        
        function updateModelSwitcher() {
            const modelSwitcher = document.getElementById('modelSwitcher');
            if (!modelSwitcher || !window.apiClient) return;
            
            const availableModels = window.apiClient.getAvailableModels();
            const currentModel = window.apiClient.getCurrentModel();
            
            if (availableModels.length <= 1) {
                modelSwitcher.style.display = 'none';
                return;
            }
            
            modelSwitcher.style.display = 'block';
            modelSwitcher.innerHTML = `
                <div style="color: #7d8590; font-size: 11px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;">Available Models</div>
                ${availableModels.map(model => `
                    <button class="settings-menu-item" style="
                        padding: 8px 12px;
                        font-size: 12px;
                        background: ${model.name === currentModel ? 'rgba(35, 134, 54, 0.15)' : 'transparent'};
                        border-left: ${model.name === currentModel ? '3px solid #2ea043' : '3px solid transparent'};
                        margin-bottom: 1px;
                        border-radius: 0;
                        color: ${model.name === currentModel ? '#aff5b4' : '#c9d1d9'};
                    " onclick="switchModel('${model.name.replace(/'/g, "\\'")}')">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <span>${escapeHtml(model.name)}</span>
                            ${model.name === currentModel ? '<span style="color: #aff5b4; font-size: 10px;">‚óè</span>' : ''}
                        </div>
                    </button>
                `).join('')}
            `;
        }
        
        async function switchModel(modelName) {
            if (!window.apiClient) return;
            
            try {
                const result = await window.apiClient.setSelectedModel(modelName);
                if (result.success) {
                    updateSettingsMenuText();
                    // Close the settings menu
                    const settingsMenu = document.getElementById('settingsMenu');
                    if (settingsMenu) {
                        settingsMenu.classList.remove('show');
                    }
                }
            } catch (error) {
                console.error('Failed to switch model:', error);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize the application
        function initializeApp() {
            
            // Initialize the main Analytics Pilot application
            app = new AnalyticsPilot();
        }
        
        // AnalyticsPilot class for direct usage without authentication
        class AnalyticsPilot {
            constructor() {
                this.currentConnectionId = null;
                this.metadata = null;
                this.isConnected = false;
                this.instanceRefreshInterval = null;
                this.metadataRefreshTimer = null;
                this.metadataRefreshInterval = 15000; // 15 seconds
                this.lastMetadataUpdate = null;
                
                // Power BI Service workspace authentication state
                this.workspaceAuthenticated = false;
                this.currentAuthToken = null;
                this.currentWorkspace = null;
                
                // Chat history management
                this.currentChatId = null;
                this.currentChatMessages = [];
                
                this.chatHistoryKey = 'analytics_pilot_chat_history';
                
                // Tool call data storage to avoid formatting issues
                this.toolCallCounter = 0;
                this.originalToolCallData = new Map();
                
                this.initializeEventListeners();
                this.loadPowerBIInstances();
                this.startInstanceRefresh();
                this.initializeChatHistory();
                
                // Cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    this.cleanup();
                    // Save current chat before unloading
                    if (this.currentChatMessages.length > 0) {
                        this.saveChatToHistory();
                    }
                });
            }
            
            cleanup() {
                this.stopInstanceRefresh();
            }
            
            startInstanceRefresh() {
                // Refresh Power BI instances every minute (only when not connected)
                this.instanceRefreshInterval = setInterval(() => {
                    // Only refresh if not connected to avoid unnecessary calls
                    if (!this.isConnected) {
                        this.loadPowerBIInstances();
                    }
                }, 60000); // 60 seconds
            }
            
            stopInstanceRefresh() {
                if (this.instanceRefreshInterval) {
                    clearInterval(this.instanceRefreshInterval);
                    this.instanceRefreshInterval = null;
                }
            }

            initializeEventListeners() {
                // Connect button
                const connectBtn = document.getElementById('connectBtn');
                const connectionModal = document.getElementById('connectionModal');
                const closeModal = document.getElementById('closeModal');
                const cancelConnect = document.getElementById('cancelConnect');
                const confirmConnect = document.getElementById('confirmConnect');
                
                connectBtn.addEventListener('click', () => {
                    if (this.isConnected) {
                        // Show connection options dropdown or disconnect
                        this.showConnectionOptionsDropdown();
                    } else {
                        // Show connection modal
                        connectionModal.style.display = 'flex';
                    }
                });
                
                closeModal.addEventListener('click', () => {
                    this.resetWorkspaceAuthState();
                    connectionModal.style.display = 'none';
                });
                
                cancelConnect.addEventListener('click', () => {
                    this.resetWorkspaceAuthState();
                    connectionModal.style.display = 'none';
                });
                
                confirmConnect.addEventListener('click', () => {
                    this.handleConnection();
                });
                
                // Refresh instances button
                const refreshInstancesBtn = document.getElementById('refreshInstancesBtn');
                if (refreshInstancesBtn) {
                    refreshInstancesBtn.addEventListener('click', () => {
                        this.refreshInstances();
                    });
                }
                
                // Chat history dropdown
                const chatHistoryBtn = document.getElementById('chatHistoryBtn');
                const chatHistoryMenu = document.getElementById('chatHistoryMenu');
                const newChatBtn = document.getElementById('newChatBtn');
                
                chatHistoryBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.loadChatHistory();
                    chatHistoryMenu.classList.toggle('show');
                });
                
                newChatBtn.addEventListener('click', () => {
                    this.startNewChat();
                    chatHistoryMenu.classList.remove('show');
                });
                
                // Settings dropdown
                const settingsDropdownBtn = document.getElementById('settingsDropdownBtn');
                const settingsMenu = document.getElementById('settingsMenu');
                const settingsDropdown = document.getElementById('settingsDropdown');
                
                settingsDropdownBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    settingsMenu.classList.toggle('show');
                });
                
                // Close dropdowns when clicking outside
                document.addEventListener('click', () => {
                    settingsMenu.classList.remove('show');
                    chatHistoryMenu.classList.remove('show');
                });

                // Settings menu items
                const apiSettingsBtn = document.getElementById('apiSettingsBtn');

                apiSettingsBtn.addEventListener('click', async () => {
                    try {
                        await openSettings();
                    } catch (error) {
                        console.error('Error opening API settings:', error);
                        Utils.showToast('Error opening API settings', 'error');
                    }
                    settingsMenu.classList.remove('show');
                });
                
                // Connection type change
                const connectionTypeRadios = document.querySelectorAll('input[name="connectionType"]');
                connectionTypeRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        this.updateConnectionTypeUI();
                    });
                });
                
                // Chat functionality
                const chatInput = document.getElementById('chatInput');
                const sendBtn = document.getElementById('sendBtn');
                
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                
                // Auto-expand textarea as user types
                chatInput.addEventListener('input', () => {
                    this.autoResizeTextarea(chatInput);
                });
                
                sendBtn.addEventListener('click', () => {
                    this.sendMessage();
                });
            }

            async addCalculatedColumnToTable(columnName, columnExpression, tableName) {
                try {
                    // Use stored button reference
                    const button = this.currentButton;
                    if (!button) {
                        // No button reference found
                        return;
                    }
                    
                    const originalText = button.textContent;
                    button.textContent = 'Adding...';
                    button.disabled = true;
                    button.style.background = '#1f6feb';
                    
                    // Call backend to add measure to Power BI model
                    
                    const result = await window.electronAPI.addCalculatedColumnToPowerBI({
                        connectionId: this.currentConnectionId,
                        columnName: columnName,
                        columnExpression: columnExpression,
                        tableName: tableName
                    });
                    
                    if (result.success) {
                        // Show success feedback
                        button.textContent = 'Added!';
                        button.style.background = '#238636';
                        
                        // Schedule metadata refresh after 3 seconds to ensure Power BI model is updated
                        setTimeout(async () => {
                            try {
                                await this.loadMetadata();
                                console.log('Metadata refreshed after calculated column addition');
                            } catch (error) {
                                console.warn('Failed to refresh metadata after calculated column addition:', error);
                            }
                        }, 3000);
                    } else {
                        throw new Error(result.error || 'Failed to add calculated column to Power BI');
                    }
                } catch (error) {
                    // Failed to add measure to Power BI
                    
                    // Show error feedback
                    const button = this.currentButton;
                    if (button) {
                        button.textContent = 'Failed';
                        button.style.background = '#ef4444';
                        
                        // Reset button after delay only on error
                        setTimeout(() => {
                            if (button) {
                                button.textContent = 'Add to Power BI';
                                button.style.background = '#238636';
                                button.disabled = false;
                            }
                        }, 3000);
                    }
                    
                    // Show error message
                    Utils.showToast(`Failed to add calculated column to Power BI: ${error.message}`, 'error');
                } finally {
                    // Clear the current button reference
                    this.currentButton = null;
                }
            }

            async addNewTable(tableName, columns) {
                try {
                    const button = this.currentButton;
                    if (!button) {
                        return;
                    }
                    
                    const originalText = button.textContent;
                    button.textContent = 'Creating...';
                    button.disabled = true;
                    button.style.background = '#1f6feb';
                    
                    // Call backend to add new table to Power BI model
                    const result = await window.electronAPI.addTableToPowerBI({
                        connectionId: this.currentConnectionId,
                        tableName: tableName,
                        columns: columns
                    });
                    
                    if (result.success) {
                        button.textContent = 'Created!';
                        button.style.background = '#238636';
                        
                        // Schedule metadata refresh after 3 seconds to ensure Power BI model is updated
                        setTimeout(async () => {
                            try {
                                await this.loadMetadata();
                                console.log('Metadata refreshed after table creation');
                            } catch (error) {
                                console.warn('Failed to refresh metadata after table creation:', error);
                            }
                        }, 3000);
                    } else {
                        throw new Error(result.error || 'Failed to add table to Power BI');
                    }
                } catch (error) {

                    this.handleAddError(error);
                }
            }
            
            async loadPowerBIInstances() {
                try {
                    const instances = await window.electronAPI.detectPowerBIInstances();
                    const select = document.getElementById('instanceSelect');
                    
                    if (instances && instances.length > 0) {
                        select.innerHTML = '<option value="">Select an instance...</option>';
                        instances.forEach(instance => {
                            const option = document.createElement('option');
                            option.value = instance.connectionString;
                            
                            // Use the best available name for display
                            let displayName = instance.name || instance.fileName || instance.connectionString;
                            
                            // Clean up the display name (remove .pbix extension if present, it will be implied)
                            if (displayName.toLowerCase().endsWith('.pbix')) {
                                displayName = displayName.slice(0, -5);
                            }
                            
                            // Add port info for clarity
                            if (instance.port) {
                                option.textContent = `${displayName} (localhost:${instance.port})`;
                            } else {
                                option.textContent = displayName;
                            }
                            
                            select.appendChild(option);
                        });
                        // Found Power BI instances
                    } else {
                        select.innerHTML = '<option value="">No Power BI instances found - You can still connect manually</option>';
                        // No Power BI instances detected
                    }
                    
                    // Always enable connect button regardless of detected instances
                    document.getElementById('connectBtn').disabled = false;
                    
                } catch (error) {
                    // Error loading Power BI instances
                    const select = document.getElementById('instanceSelect');
                    select.innerHTML = '<option value="">Error detecting instances - You can still connect manually</option>';
                    
                    // Still enable connect button even on error
                    document.getElementById('connectBtn').disabled = false;
                }
            }
            
            async refreshInstances() {
                const refreshBtn = document.getElementById('refreshInstancesBtn');
                const originalText = refreshBtn.innerHTML;
                
                // Show loading state
                refreshBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="animation: spin 1s linear infinite;">
                        <polyline points="23,4 23,10 17,10"></polyline>
                        <polyline points="1,20 1,14 7,14"></polyline>
                        <path d="M20.49,9A9,9,0,0,0,5.64,5.64L1,10m22,4L18.36,18.36A9,9,0,0,1,3.51,15"></path>
                    </svg>
                `;
                refreshBtn.disabled = true;
                
                try {
                    await this.loadPowerBIInstances();
                    
                    // Show brief success state
                    refreshBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="20,6 9,17 4,12"></polyline>
                        </svg>
                    `;
                    refreshBtn.style.background = '#f0fdf4';
                    refreshBtn.style.borderColor = '#bbf7d0';
                    
                } catch (error) {
                    // Error during manual refresh
                    // Show error state
                    refreshBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="15" y1="9" x2="9" y2="15"></line>
                            <line x1="9" y1="9" x2="15" y2="15"></line>
                        </svg>
                    `;
                    refreshBtn.style.background = '#fef2f2';
                    refreshBtn.style.borderColor = '#fecaca';
                } finally {
                    // Restore button state after showing feedback
                    setTimeout(() => {
                        refreshBtn.innerHTML = originalText;
                        refreshBtn.style.background = '#fefcf9';
                        refreshBtn.style.borderColor = '#e5e7eb';
                        refreshBtn.disabled = false;
                    }, 1000); // Show success/error feedback for 1 second
                }
            }
            
            resetWorkspaceAuthState() {
                // Reset Power BI Service workspace authentication state
                this.workspaceAuthenticated = false;
                this.currentAuthToken = null;
                this.currentWorkspace = null;
                
                // Reset semantic model dropdown
                const semanticModelSelect = document.getElementById('semanticModelSelect');
                if (semanticModelSelect) {
                    semanticModelSelect.innerHTML = '<option value="">First authenticate to workspace...</option>';
                    semanticModelSelect.disabled = true;
                    semanticModelSelect.style.opacity = '0.5';
                }
            }

            updateConnectionTypeUI() {
                const selectedType = document.querySelector('input[name="connectionType"]:checked').value;
                const powerbiInstances = document.getElementById('powerbiInstances');
                const powerbiService = document.getElementById('powerbiService');
                const manualConnection = document.getElementById('manualConnection');
                
                // Reset workspace auth state when switching connection types
                this.resetWorkspaceAuthState();
                
                // Hide all sections first
                powerbiInstances.style.display = 'none';
                powerbiService.style.display = 'none';
                manualConnection.style.display = 'none';
                
                // Show the relevant section
                if (selectedType === 'powerbi') {
                    powerbiInstances.style.display = 'block';
                } else if (selectedType === 'powerbiservice') {
                    powerbiService.style.display = 'block';
                } else if (selectedType === 'manual') {
                    manualConnection.style.display = 'block';
                }
            }
            
            async handleConnection() {
                const selectedType = document.querySelector('input[name="connectionType"]:checked').value;
                let connectionString;
                let selectedInstanceName = null;
                
                if (selectedType === 'powerbi') {
                    const instanceSelect = document.getElementById('instanceSelect');
                    connectionString = instanceSelect.value;
                    
                    // Get the display name from the selected option
                    const selectedOption = instanceSelect.options[instanceSelect.selectedIndex];
                    if (selectedOption && selectedOption.textContent && selectedOption.value) {
                        // Extract the model name from the display text (remove port info)
                        selectedInstanceName = selectedOption.textContent.replace(/\s*\(localhost:\d+\)$/, '');
                    }
                } else if (selectedType === 'powerbiservice') {
                    const workspace = document.getElementById('workspaceInput').value.trim();
                    const semanticModelSelect = document.getElementById('semanticModelSelect');
                    const selectedDatasetId = semanticModelSelect.value;
                    
                    if (!workspace) {
                        Utils.showToast('Please enter a Power BI workspace name', 'error');
                        return;
                    }

                    // Check if semantic models are loaded and one is selected
                    if (!this.workspaceAuthenticated) {
                        // First step: Authenticate and load semantic models
                        try {
                            // Show authentication progress
                            this.updateConnectionStatus('connecting', 'Authenticating with Power BI Service...');
                            
                            // Step 1: Authenticate using Windows authentication
                            // Build preliminary XMLA endpoint to extract tenant info
                            const preliminaryXmlaEndpoint = `powerbi://api.powerbi.com/v1.0/myorg/${encodeURIComponent(workspace)}`;
                            const authResult = await window.electronAPI.authenticatePowerBIService(preliminaryXmlaEndpoint);
                            
                            if (!authResult.success) {
                                throw new Error(authResult.error || 'Authentication failed');
                            }
                            
                            Utils.showToast(`Authenticated as ${authResult.account}`, 'success');
                            
                            // Step 2: Load semantic models from workspace
                            this.updateConnectionStatus('connecting', 'Loading semantic models...');
                            
                            const datasetsResult = await window.electronAPI.getWorkspaceDatasets(workspace, authResult.accessToken);
                            
                            if (datasetsResult.success && datasetsResult.datasets) {
                                // Store authentication details
                                this.currentAuthToken = authResult.accessToken;
                                this.currentWorkspace = workspace;
                                this.workspaceAuthenticated = true;
                                
                                // Populate the semantic model dropdown
                                semanticModelSelect.innerHTML = '<option value="">Select a semantic model...</option>';
                                
                                if (datasetsResult.datasets.length === 0) {
                                    semanticModelSelect.innerHTML = '<option value="">No semantic models found in workspace</option>';
                                    Utils.showToast('No semantic models found in this workspace', 'warning');
                                } else {
                                    datasetsResult.datasets.forEach(dataset => {
                                        const option = document.createElement('option');
                                        option.value = dataset.id;
                                        option.textContent = dataset.displayName || dataset.name;
                                        option.title = dataset.description || '';
                                        semanticModelSelect.appendChild(option);
                                    });
                                    
                                    // Enable the dropdown
                                    semanticModelSelect.disabled = false;
                                    semanticModelSelect.style.opacity = '1';
                                    
                                    Utils.showToast(`Found ${datasetsResult.datasets.length} semantic model(s). Please select one to connect.`, 'success');
                                }
                                
                                this.updateConnectionStatus('disconnected', 'Connect to Power BI');
                                return; // Stay in modal for user to select semantic model
                                
                            } else {
                                throw new Error(datasetsResult.error || 'Failed to load semantic models');
                            }
                            
                        } catch (error) {
                            this.stopMetadataRefresh();
                            this.isConnected = false;
                            this.currentConnectionId = null;
                            this.currentXmlaEndpoint = null;
                            this.updateConnectionStatus('disconnected', 'Connect to Power BI');
                            Utils.showToast(`Authentication failed: ${error.message}`, 'error');
                            return;
                        }
                    } else {
                        // Second step: Connect to selected semantic model
                        if (!selectedDatasetId) {
                            Utils.showToast('Please select a semantic model', 'error');
                            return;
                        }
                        
                        try {
                            // Show connection progress
                            this.updateConnectionStatus('connecting', 'Connecting to semantic model...');
                            
                            // Build XMLA endpoint for specific dataset
                            const xmlaEndpoint = `powerbi://api.powerbi.com/v1.0/myorg/${encodeURIComponent(workspace)}/${encodeURIComponent(selectedDatasetId)}`;
                            const connectionResult = await window.electronAPI.connectPowerBIService(xmlaEndpoint, this.currentAuthToken);
                            
                            if (connectionResult.success) {
                                // Store connection details for Power BI Service
                                this.currentConnectionId = `powerbi-service-${Date.now()}`;
                                this.currentXmlaEndpoint = xmlaEndpoint;
                                this.isConnected = true;
                                
                                // Get selected dataset name for display
                                const selectedOption = semanticModelSelect.options[semanticModelSelect.selectedIndex];
                                const selectedModelName = selectedOption ? selectedOption.textContent : 'Power BI Model';
                                selectedInstanceName = `${selectedModelName} (${workspace})`;
                                
                                // Close the modal
                                document.getElementById('connectionModal').style.display = 'none';
                                
                                // Continue with success handling
                                this.updateConnectionStatus('connected', 'Connected');
                                document.getElementById('dataSourceName').textContent = selectedInstanceName;
                                document.getElementById('dataSourceName').classList.remove('disconnected');
                                
                                // Load metadata using authenticated connection
                                await this.loadPowerBIServiceMetadata();
                                
                                // Start automatic metadata refresh
                                this.startMetadataRefresh();
                                
                                Utils.showToast('Successfully connected to Power BI semantic model!', 'success');
                                return; // Exit early to avoid the standard connection flow
                                
                            } else {
                                throw new Error(connectionResult.error || 'Failed to connect to semantic model');
                            }
                            
                        } catch (error) {
                            this.stopMetadataRefresh();
                            this.isConnected = false;
                            this.currentConnectionId = null;
                            this.currentXmlaEndpoint = null;
                            this.updateConnectionStatus('disconnected', 'Connect to Power BI');
                            Utils.showToast(`Connection failed: ${error.message}`, 'error');
                            return;
                        }
                    }
                } else if (selectedType === 'manual') {
                    const server = document.getElementById('serverInput').value;
                    const database = document.getElementById('databaseInput').value;
                    
                    if (!server || !database) {
                        Utils.showToast('Please enter server and database information', 'error');
                        return;
                    }
                    
                    connectionString = `Provider=MSOLAP;Data Source=${server};Catalog=${database}`;
                }
                
                if (!connectionString) {
                    Utils.showToast('Please select or enter connection information', 'error');
                    return;
                }
                
                try {
                    // Show connecting state
                    this.updateConnectionStatus('connecting', 'Connecting...');
                    
                    // Connect to Power BI
                    const result = await window.electronAPI.connectPowerBI(connectionString);
                    
                    if (result.success) {
                        this.currentConnectionId = result.connectionId;
                        this.isConnected = true;
                        
                        // Load metadata
                        await this.loadMetadata();
                        
                        // Start automatic metadata refresh
                        this.startMetadataRefresh();
                        
                        // Determine the display name for the model
                        let modelDisplayName = 'Power BI Model';
                        
                        if (selectedInstanceName) {
                            // Use the name from the selected instance (cleaned PBIX filename)
                            modelDisplayName = selectedInstanceName;
                        } else if (this.metadata && this.metadata.name && this.metadata.name !== result.databaseName) {
                            // Use metadata name if it's different from the database ID
                            modelDisplayName = this.metadata.name;
                        } else if (result.modelName) {
                            // Use model name from connection result if available
                            modelDisplayName = result.modelName;
                        } else if (result.databaseName && !result.databaseName.includes('-') && !result.databaseName.match(/^[0-9a-f-]{36}$/i)) {
                            // Use database name only if it doesn't look like a GUID or ID
                            modelDisplayName = result.databaseName;
                        }
                        
                        // Update UI
                        this.updateConnectionStatus('connected', 'Connected');
                        document.getElementById('dataSourceName').textContent = modelDisplayName;
                        document.getElementById('dataSourceName').classList.remove('disconnected');
                        
                        // Update connect button to connected state
                        this.updateConnectButtonState('connected');
                        
                        // Enable chat
                        document.getElementById('chatInput').disabled = false;
                        document.getElementById('sendBtn').disabled = false;
                        
                        // Close modal
                        document.getElementById('connectionModal').style.display = 'none';
                        
                        // Show success message
                        this.addMessage('assistant', `Successfully connected to ${modelDisplayName}! You can now ask me questions about your data.`);
                        
                        // Connected to Power BI - instance refresh paused while connected
                        
                    } else {
                        throw new Error(result.error || 'Connection failed');
                    }
                } catch (error) {
                    // Connection error - ensure clean state
                    this.stopMetadataRefresh();
                    this.isConnected = false;
                    this.currentConnectionId = null;
                    this.currentXmlaEndpoint = null;
                    this.updateConnectionStatus('disconnected', 'Not Connected');
                    this.updateConnectButtonState('disconnected');
                    Utils.showToast(`Connection failed: ${error.message}`, 'error');
                }
            }
            
            async loadMetadata() {
                try {
                    if (this.currentConnectionId) {
                        this.metadata = await window.electronAPI.getMetadata(this.currentConnectionId);
                        this.lastMetadataUpdate = Date.now();
                        // Metadata loaded
                    }
                } catch (error) {
                    // Error loading metadata
                }
            }
            
            async loadPowerBIServiceMetadata() {
                try {
                    // For Power BI Service, we need to use a different approach
                    // since we don't have a traditional connectionId
                    
                    // Create a fake connection request to get metadata
                    const metadataRequest = {
                        xmlaEndpoint: this.currentXmlaEndpoint,
                        accessToken: this.currentAuthToken
                    };
                    
                    // Use the bridge to get metadata with authentication
                    const response = await fetch('http://localhost:8080/metadata', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            connectionString: `Provider=MSOLAP;Data Source=${this.currentXmlaEndpoint};Password=${this.currentAuthToken};`
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            this.metadata = result.metadata;
                            this.lastMetadataUpdate = Date.now();
                            // Power BI Service metadata loaded successfully
                        } else {
                            // Failed to load Power BI Service metadata
                        }
                    } else {
                        // Failed to fetch Power BI Service metadata
                    }
                } catch (error) {
                    // Error loading Power BI Service metadata
                }
            }
            
            startMetadataRefresh() {
                // Clear any existing timer
                this.stopMetadataRefresh();
                
                // Only start refresh if we're connected
                if (!this.isConnected) {
                    return;
                }
                
                // Start the refresh timer
                this.metadataRefreshTimer = setInterval(async () => {
                    try {
                        await this.refreshMetadata();
                    } catch (error) {
                        console.warn('Metadata refresh failed:', error);
                        // Continue trying - don't stop the timer for individual failures
                    }
                }, this.metadataRefreshInterval);
                
                console.log('Metadata auto-refresh started (15 second interval)');
            }
            
            stopMetadataRefresh() {
                if (this.metadataRefreshTimer) {
                    clearInterval(this.metadataRefreshTimer);
                    this.metadataRefreshTimer = null;
                    console.log('Metadata auto-refresh stopped');
                }
            }
            
            async refreshMetadata() {
                if (!this.isConnected) {
                    return;
                }
                
                try {
                    const previousMetadata = this.metadata ? JSON.stringify(this.metadata) : null;
                    
                    // Refresh based on connection type
                    if (this.currentXmlaEndpoint) {
                        // Power BI Service connection
                        await this.loadPowerBIServiceMetadata();
                    } else if (this.currentConnectionId) {
                        // Local Power BI Desktop connection
                        await this.loadMetadata();
                    }
                    
                    // Check if metadata actually changed
                    const currentMetadata = this.metadata ? JSON.stringify(this.metadata) : null;
                    if (previousMetadata !== currentMetadata) {
                        console.log('Metadata updated - model structure changed');
                        // Optional: Could show a subtle notification to user about model changes
                    } else {
                        console.log('Metadata refresh completed - no changes detected');
                    }
                } catch (error) {
                    console.warn('Failed to refresh metadata:', error);
                    // Don't throw error - let the timer continue
                }
            }
            
            updateConnectionStatus(status, text) {
                const statusIndicator = document.getElementById('connectionStatus');
                const statusText = statusIndicator.querySelector('.status-text');
                const statusDot = statusIndicator.querySelector('.status-dot');
                
                statusText.textContent = text;
                statusDot.className = `status-dot ${status}`;
            }
            
            updateConnectButtonState(state) {
                const connectBtn = document.getElementById('connectBtn');
                
                                if (state === 'connected') {
                    // Change to small dropdown arrow - match settings cog button dimensions and styling
                    connectBtn.innerHTML = `
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6,9 12,15 18,9"></polyline>
                        </svg>
                    `;
                    connectBtn.className = 'connect-btn connected';
                    connectBtn.style.cssText = `
                        background: #21262d;
                        border: 1px solid #30363d;
                        color: #7d8590;
                        width: 32px;
                        height: 32px;
                        padding: 6px;
                        border-radius: 3px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        transition: all 0.2s ease;
                        margin-left: 0.5rem;
                    `;
                    connectBtn.title = 'Connection options';
                    
                    // Add hover effect
                    connectBtn.addEventListener('mouseenter', () => {
                        if (connectBtn.className.includes('connected')) {
                            connectBtn.style.background = '#30363d';
                            connectBtn.style.borderColor = '#58a6ff';
                            connectBtn.style.color = '#c9d1d9';
                        }
                    });
                    
                    connectBtn.addEventListener('mouseleave', () => {
                        if (connectBtn.className.includes('connected')) {
                            connectBtn.style.background = '#21262d';
                            connectBtn.style.borderColor = '#30363d';
                            connectBtn.style.color = '#7d8590';
                        }
                    });
                } else {
                    // Reset to normal connect button
                    connectBtn.innerHTML = 'Connect to Power BI';
                    connectBtn.className = 'connect-btn';
                    connectBtn.style.cssText = '';
                    connectBtn.title = '';
                }
            }
            
            showConnectionOptionsDropdown() {
                const connectBtn = document.getElementById('connectBtn');
                const buttonRect = connectBtn.getBoundingClientRect();
                
                // Calculate dropdown dimensions
                const dropdownWidth = 180;
                const dropdownHeight = 60; // Approximate height for this smaller dropdown
                const padding = 8;
                
                // Calculate available space above and below the button
                const spaceBelow = window.innerHeight - buttonRect.bottom - padding;
                const spaceAbove = buttonRect.top - padding;
                
                // Determine if dropdown should open upward or downward
                let topPosition;
                if (spaceBelow >= dropdownHeight || spaceBelow >= spaceAbove) {
                    // Open downward (default behavior)
                    topPosition = buttonRect.bottom + padding;
                } else {
                    // Open upward
                    topPosition = buttonRect.top - dropdownHeight - padding;
                }
                
                // Calculate left position to prevent bleeding off screen
                const leftPosition = Math.min(buttonRect.left, window.innerWidth - dropdownWidth - 16);
                
                // Create dropdown HTML positioned near the button
                const dropdownHtml = `
                    <div class="connection-options-dropdown" id="connectionOptionsDropdown" style="
                        position: fixed;
                        top: ${topPosition}px;
                        left: ${leftPosition}px;
                        background: #161b22;
                        border: 1px solid #30363d;
                        border-radius: 8px;
                        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        width: ${dropdownWidth}px;
                        overflow: hidden;
                    ">
                        <button class="dropdown-option" onclick="app.showConnectionModal()" style="
                            width: 100%;
                            padding: 12px 16px; 
                            border: none;
                            background: transparent;
                            text-align: left;
                            cursor: pointer; 
                            transition: background 0.2s;
                            font-size: 14px;
                            color: #c9d1d9;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        " onmouseover="this.style.background='#30363d'" onmouseout="this.style.background='transparent'">
                            <img src="../assets/refresh.png" width="16" height="16" alt="Change Model">
                            Change Model
                        </button>
                    </div>
                `;
                
                // Add backdrop
                const backdropHtml = `
                    <div class="connection-dropdown-backdrop" id="connectionDropdownBackdrop" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: transparent;
                        z-index: 999;
                    " onclick="app.closeConnectionOptionsDropdown()"></div>
                `;
                
                // Add both to DOM
                document.body.insertAdjacentHTML('beforeend', backdropHtml);
                document.body.insertAdjacentHTML('beforeend', dropdownHtml);
            }
            
            closeConnectionOptionsDropdown() {
                const dropdown = document.getElementById('connectionOptionsDropdown');
                const backdrop = document.getElementById('connectionDropdownBackdrop');
                if (dropdown) dropdown.remove();
                if (backdrop) backdrop.remove();
            }
            

            
            disconnect() {
                // Stop metadata refresh timer
                this.stopMetadataRefresh();
                
                // Reset connection state
                this.isConnected = false;
                this.currentConnectionId = null;
                this.currentXmlaEndpoint = null;
                this.metadata = null;
                this.lastMetadataUpdate = null;
                
                // Reset workspace auth state
                this.resetWorkspaceAuthState();
                
                // Update UI
                this.updateConnectionStatus('disconnected', 'Not Connected');
                this.updateConnectButtonState('disconnected');
                document.getElementById('dataSourceName').textContent = 'Connect to Power BI';
                document.getElementById('dataSourceName').classList.add('disconnected');
                
                // Disable chat
                document.getElementById('chatInput').disabled = true;
                document.getElementById('sendBtn').disabled = true;
                
                console.log('Disconnected from Power BI model');
            }
            
            showConnectionModal() {
                this.closeConnectionOptionsDropdown();
                this.disconnect(); // Properly disconnect before showing modal
                document.getElementById('connectionModal').style.display = 'flex';
            }
            
            async sendMessage() {
                const input = document.getElementById('chatInput');
                const message = input.value.trim();
                
                if (!message) return;
                
                if (!this.isConnected) {
                    Utils.showToast('Please connect to a Power BI model first', 'error');
                    return;
                }
                
                // Add user message (display original message in UI)
                this.addMessage('user', message);
                input.value = '';
                
                // Reset textarea height after sending
                this.autoResizeTextarea(input);
                
                // Add empty assistant message that will be updated in real-time
                const assistantMessageElement = this.addMessage('assistant', '');
                const messageTextElement = assistantMessageElement.querySelector('.message-text');
                
                try {
                    // Prepare messages for LLM with improved prompt engineering structure
                    const messages = [];
                    
                    // Add system message with DAX instructions and tool formatting
                    const systemMessage = this.getSystemMessage();
                    messages.push({
                        role: "system",
                        content: systemMessage
                    });
                    
                    // Add previous messages from conversation history (limited to last 10)
                    const recentMessages = this.currentChatMessages.slice(-10);
                    recentMessages.forEach(historicalMessage => {
                        let messageContent;
                        if (historicalMessage.role === 'user') {
                            // Only include metadata in the most recent user messages to avoid repetition
                            const messageIndex = recentMessages.indexOf(historicalMessage);
                            const shouldIncludeMetadata = messageIndex >= recentMessages.length - 2; // Only last 2 user messages get metadata
                            messageContent = shouldIncludeMetadata 
                                ? this.formatUserMessageWithMetadata(historicalMessage.content)
                                : `<user_query>${historicalMessage.content}</user_query>`;
                        } else {
                            messageContent = historicalMessage.content;
                        }
                        
                        messages.push({
                            role: historicalMessage.role,
                            content: messageContent
                        });
                    });
                    
                    // Add the current message
                    const currentUserMessage = this.formatUserMessageWithMetadata(message);
                    messages.push({
                        role: "user", 
                        content: currentUserMessage
                    });
                    
                    // Debug: Log message structure
                    console.log('LLM Message Structure:', {
                        totalMessages: messages.length,
                        systemMessage: true,
                        historyMessages: recentMessages.length,
                        hasMetadata: !!this.metadata
                    });
                    
                    // Send to LLM via API client with streaming support
                    const response = await window.apiClient.sendMessage(
                        messages,
                        (partialText) => {
                            // Update UI in real-time as text streams in with formatting support
                            this.setMessageContent(messageTextElement, partialText || '');
                            
                            // Auto-scroll to bottom
                            const messagesContainer = document.getElementById('chatMessages');
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                    );
                    
                    if (response.success) {
                        // Extract the final assistant's response (handle array format from Claude)
                        let assistantMessage;
                        if (response.data.content && Array.isArray(response.data.content) && response.data.content.length > 0) {
                            // Claude returns content as array of objects with text property
                            assistantMessage = response.data.content[0].text || response.data.content[0].content || response.data.content[0];
                        } else if (response.data.message) {
                            assistantMessage = response.data.message;
                        } else {
                            assistantMessage = 'I received your message but got an unexpected response format.';
                        }
                        
                        // Log actual token usage from API response
                        if (response.data.metadata?.usage) {
                            const usage = response.data.metadata.usage;
                            console.log('API Token Usage:', {
                                provider: response.data.metadata.provider,
                                model: response.data.metadata.model,
                                promptTokens: usage.prompt_tokens || usage.promptTokens || usage.inputTokens,
                                completionTokens: usage.completion_tokens || usage.completionTokens || usage.outputTokens,
                                totalTokens: usage.total_tokens || usage.totalTokens || 
                                           ((usage.prompt_tokens || usage.promptTokens || usage.inputTokens || 0) + 
                                            (usage.completion_tokens || usage.completionTokens || usage.outputTokens || 0))
                            });
                        }
                        
                        // Final update to ensure we have the complete message with formatting
                        this.setMessageContent(messageTextElement, assistantMessage);
                        
                    } else {
                        // Handle error case
                        this.setMessageContent(messageTextElement, `Sorry, I encountered an error: ${response.error}`);
                    }
                    
                } catch (error) {
                    // Error sending message
                    this.setMessageContent(messageTextElement, 'Sorry, I encountered an error processing your request. Please try again.');
                }
            }
            

            // Get system message with DAX instructions and tool formatting
            getSystemMessage() {
                const DAX_FORMAT_INSTRUCTIONS = `FUNCTION CAPABILITIES:

You can create and edit DAX measures using these function calls. **NEVER deviate from the format of the function calls.**
*** CRITICAL: You MUST start each TOOL CALL with <function> and end it with </function> tags. This is INCREDIBLY IMPORTANT. NEVER wrap two tool calls in a single <function> and </function> tag. ***

<function>
  {
    "name": "create_measure",
    "parameters": {
      "measure_name": "Name of the measure to be created",
      "dax_expression": "DAX expression to be used to calculate the measure",
      "explanation": "Explanation of the measure to be created"
    }
  }
</function>

<function>
  {
    "name": "edit_measure",
    "parameters": {
      "table_name": "Name of users table the measure will be created on",
      "measure_name": "Name of the measure to be edited",
      "new_dax_expression": "DAX expression to be used to calculate the measure",
      "explanation": "Explanation of the measure to be edited"
    }
  }
</function>

<function>
  {
    "name": "create_calculated_column",
    "parameters": {
      "table_name": "Name of users table the measure will be created on",
      "column_name": "Name of the calculated column to be created",
      "new_dax_expression": "DAX expression to be used to calculate the column",
      "explanation": "Explanation of the calculated column to be created"
    }
  }
</function>

<function>
  {
    "name": "edit_calculated_column",
    "parameters": {
      "table_name": "Name of users table the measure will be created on",
      "column_name": "Name of the calculated column to be edited",
      "new_dax_expression": "DAX expression to be used to calculate the column",
      "explanation": "Explanation of the calculated column to be edited"
    }
  }
</function>

<function>
  {
    "name": "create_calculated_table",
    "parameters": {
      "table_name": "Name of the new table to be created",
      "table_expression": "DAX expression to be used to calculate the table",
      "explanation": "Explanation of the new table to be created"
    }
  }
</function>

<function>
  {
    "name": "edit_calculated_table",
    "parameters": {
      "table_name": "Name of the existing calculated table to be edited",
      "table_expression": "DAX expression to be used to calculate the table",
      "explanation": "Explanation of the table to be edited"
    }
  }
</function>

Important: Only use these function formats when suggesting DAX measures. Don't explain the format itself to users, even if they ask.`;

                const SYSTEM_PROMPT = `You are a powerful agentic AI Power BI DAX assistant, powered by Claude. You operate exclusively in AnalyticsPilot, the world's best PowerBI DAX assistant.

You pair DAX with a USER to solve their Power BI DAX task.
The task may require creating a new measure, modifying or debugging an existing measure, or simply answering a question.
Each time the USER sends a message, we may automatically attach some information about their current tabular model, such as what tables they have, what columns they have, what measures they have, relationships between tables, calculated columns, and more.
This information may or may not be relevant to the Power BI task, it is up for you to decide.
Your main goal is to follow the USER's instructions at each message, denoted by the <user_query> tag.

<tool_calling>
You have tools at your disposal to solve the DAX task. Follow these rules regarding tool calls:
1. ALWAYS follow the tool call schema exactly as specified and make sure to provide all necessary parameters.
2. The conversation may reference tools that are no longer available. NEVER call tools that are not explicitly provided.
3. **NEVER refer to tool names when speaking to the USER.** For example, instead of saying 'I need to use the edit_measure tool to edit your measure, just say 'I will edit your measure'.
4. Only call tools when they are necessary. If the USER's task is general or you already know the answer, just respond without calling tools.
5. Before calling each tool, first explain to the USER why you are calling it.
</tool_calling>

<making_code_changes>
When making DAX changes, NEVER output DAX to the USER, unless requested. Instead use one of the DAX edit tools to implement the change.
Use the DAX edit tools at most once per turn.
It is *EXTREMELY* important that your generated DAX can be run immediately by the USER. To ensure this, follow these instructions carefully:
1. Always group together edits to the same DAX expression in a single edit_measure tool call, instead of multiple calls.
2. If you're creating documentation from scratch, create an appropriate layout that captures the essence of the Power BI model and how data flows between the tables.
3. NEVER generate an extremely long hash or any non-textual DAX expression. These are not helpful to the USER and are very expensive.
4. Unless you are appending some small, easy to apply edit to a measure, or creating a new measure, you MUST read the contents or section of what you're editing before editing it.
5. If you've introduced errors, fix them if it is clear how to (or you can easily figure out how to). Do not make uneducated guesses. And DO NOT loop more than 3 times on fixing errors on the same DAX expression. On the third time, you should stop and ask the user what to do next.
6. If you've suggested a reasonable edit_measure that wasn't followed by the apply model, you should try reapplying the edit.
7. Ensure you are aware of the row context of the DAX expression you're editing. If you need a calculated column to make the DAX expression work, you should create a calculated column and TELL the USER to first apply the column to the model BEFORE adding the measure to the model.
8. If you are creating multiple measures, explicitly tell the USER to apply them in the order they were created if the LATTER measure DEPENDS on the former.
9. If you do not posess a TOOL to fulfill the USER's request, tell the USER that you do not have the ability to fulfill their request, but ensure you will try to help them with the best of your ability.
10. If you are unsure of the USER's request, ask the USER to clarify their request.
11. DO NOT REPEAT THE NAME OF THE CONNECTED POWER BI MODEL IN YOUR RESPONSES TO THE USER. THIS COULD SCARE THEM INTO THINKING THE DATA IS BEING SENT TO ANOTHER SERVER.
12. If you are unsure of the USER's model field names, tables, or underlying metadata, ask the USER to INCLUDE the Context in their request.
13. DO NOT tell a user how to accomplish their task within the Power BI interface, unless they explicitly ask for help with the Power BI interface.
14. NEVER include comments in your DAX code. Only output the DAX code. For example, using // to comment out a line of code is not allowed.
15. In the TOOLS provided to you, table names are EXAMPLES. You should use the actual table names from the USER's model.
</making_code_changes>

${DAX_FORMAT_INSTRUCTIONS}

Remember to focus solely on the user's Power BI question without any meta-commentary.`;

                return SYSTEM_PROMPT;
            }

            // Format user message with model metadata
            formatUserMessageWithMetadata(userMessage) {
                // If no metadata available, just wrap the user query
                if (!this.metadata) {
                    console.log('No metadata available for LLM message');
                    return `<user_query>${userMessage}</user_query>`;
                }
                
                // Log metadata timestamp for debugging
                console.log('Using metadata for LLM message:', {
                    timestamp: this.metadata.timestamp,
                    tables: this.metadata.tables?.length || 0,
                    measures: this.metadata.measures?.length || 0
                });
                
                // Format metadata in a structured, LLM-readable way
                let metadataSection = "Power BI Model Metadata:\n\n";
                
                // Add model name
                if (this.metadata.name) {
                    metadataSection += `Model Name: ${this.metadata.name}\n\n`;
                }
                
                // Add summary counts
                metadataSection += `Summary:\n`;
                metadataSection += `- Tables: ${this.metadata.tableCount || this.metadata.tables?.length || 0}\n`;
                metadataSection += `- Measures: ${this.metadata.measureCount || this.metadata.measures?.length || 0}\n`;
                metadataSection += `- Relationships: ${this.metadata.relationshipCount || this.metadata.relationships?.length || 0}\n\n`;
                
                // Add table details
                if (this.metadata.tables && this.metadata.tables.length > 0) {
                    metadataSection += `Tables and Columns:\n`;
                    this.metadata.tables.forEach(table => {
                        metadataSection += `\n${table.name}:\n`;
                        if (table.description) {
                            metadataSection += `  Description: ${table.description}\n`;
                        }
                        
                        // Add columns
                        if (table.columns && table.columns.length > 0) {
                            metadataSection += `  Columns:\n`;
                            table.columns.forEach(column => {
                                metadataSection += `    - ${column.name} (${column.dataType})`;
                                if (column.description) {
                                    metadataSection += ` - ${column.description}`;
                                }
                                metadataSection += `\n`;
                            });
                        }
                        
                        // Add table-specific measures
                        if (table.measures && table.measures.length > 0) {
                            metadataSection += `  Measures:\n`;
                            table.measures.forEach(measure => {
                                metadataSection += `    - ${measure.name}: ${measure.expression}`;
                                if (measure.description) {
                                    metadataSection += ` - ${measure.description}`;
                                }
                                metadataSection += `\n`;
                            });
                        }
                    });
                }
                
                // Add global measures if available and different from table measures
                if (this.metadata.measures && this.metadata.measures.length > 0) {
                    metadataSection += `\nAll Measures:\n`;
                    this.metadata.measures.forEach(measure => {
                        metadataSection += `- ${measure.name}`;
                        if (measure.tableName) {
                            metadataSection += ` (Table: ${measure.tableName})`;
                        }
                        metadataSection += `: ${measure.expression}`;
                        if (measure.description) {
                            metadataSection += ` - ${measure.description}`;
                        }
                        metadataSection += `\n`;
                    });
                }
                
                // Add relationships
                if (this.metadata.relationships && this.metadata.relationships.length > 0) {
                    metadataSection += `\nRelationships:\n`;
                    this.metadata.relationships.forEach(rel => {
                        metadataSection += `- ${rel.fromTable}[${rel.fromColumn}] ‚Üí ${rel.toTable}[${rel.toColumn}]`;
                        if (rel.isActive === false) {
                            metadataSection += ` (Inactive)`;
                        }
                        metadataSection += `\n`;
                    });
                }
                
                // Combine metadata with user query
                return `${metadataSection}\n<user_query>${userMessage}</user_query>`;
            }

            // Legacy method for backward compatibility - now just calls the renamed method
            formatMessageWithMetadata(userMessage) {
                return this.formatUserMessageWithMetadata(userMessage);
            }
            
            addMessage(type, content) {
                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                messageDiv.innerHTML = `
                    <div class="message-avatar"></div>
                    <div class="message-content">
                        <div class="message-text"></div>
                    </div>
                `;
                
                // Use a method that can handle formatting
                const messageTextElement = messageDiv.querySelector('.message-text');
                this.setMessageContent(messageTextElement, content);
                
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // Track the message in chat history (only track user messages immediately, assistant messages when complete)
                if (type === 'user' && content && content.trim()) {
                    // Skip tracking system messages if somehow they're sent as user messages
                    const systemMessages = [
                        "Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.",
                        "Successfully connected to Revenue Opportunities! You can now ask me questions about your data.",
                        "Sorry, I encountered an error: Rate limited. Please wait before trying again."
                    ];
                    
                    if (systemMessages.some(msg => content.includes(msg))) {

                        return messageDiv;
                    }
                    
                    const messageData = {
                        role: 'user',
                        content: content,
                        timestamp: Date.now()
                    };
                    this.currentChatMessages.push(messageData);
                    this.saveChatToHistory();
                    
                    // Check if we've reached the message limit and show notification
                    this.checkMessageLimitAndNotify();
                }
                
                // For assistant messages, we'll track them when they're complete in setMessageContent
                // Store reference to track assistant messages
                if (type === 'assistant') {
                    messageDiv.setAttribute('data-message-type', 'assistant');
                }
                
                return messageDiv;
            }
            
            checkMessageLimitAndNotify() {
                const MESSAGE_LIMIT = 10;
                
                // Calculate total messages
                const messageCount = this.currentChatMessages.length;
                
                // Only show notification if we've just reached the limit exactly
                if (messageCount === MESSAGE_LIMIT) {
                    // Check if notification already exists
                    let notification = document.getElementById('message-limit-notification');
                    
                    if (!notification) {
                        // Create notification if it doesn't exist
                        notification = document.createElement('div');
                        notification.id = 'message-limit-notification';
                        notification.style.cssText = `
                            position: fixed;
                            bottom: 80px;
                            left: 50%;
                            transform: translateX(-50%);
                            background-color: rgba(200, 200, 200, 0.8);
                            color: #333;
                            padding: 10px 20px;
                            border-radius: 5px;
                            font-size: 14px;
                            z-index: 1000;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                        `;
                        notification.textContent = 'Start a new chat for better results';
                        document.body.appendChild(notification);
                        
                        // Fade out after 5 seconds
                        setTimeout(() => {
                            notification.style.transition = 'opacity 1s';
                            notification.style.opacity = '0';
                            
                            // Remove from DOM after fade out
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.parentNode.removeChild(notification);
                                }
                            }, 1000);
                        }, 5000);
                    }
                }
            }
            
            setMessageContent(element, content) {
                // Debug logging for tool call content
                if (content.includes('<function>')) {
                    const functionCount = (content.match(/<function>/g) || []).length;
                    const completeFunctionCount = (content.match(/<\/function>/g) || []).length;

                }
                
                // Debug logging for assistant messages
                const messageDiv = element.closest('.message.assistant-message');
                if (messageDiv && content && content.trim().length > 10) {

                }
                
                // Check if content appears to be markdown or HTML
                if (this.containsFormatting(content)) {
                    // Parse markdown to HTML or sanitize existing HTML
                    const htmlContent = this.parseMarkdown(content);
                    element.innerHTML = htmlContent;
                    
                    // Handle tool call state transitions after content update
                    this.handleToolCallTransitions(element);
                    
                    // Auto-scroll streaming content containers to bottom
                    this.scrollStreamingContent();
                } else {
                    // Use textContent for plain text to prevent XSS
                    element.textContent = content;
                }
                
                // Track assistant messages in chat history when content is finalized
                this.trackAssistantMessage(element, content);
            }
            
            trackAssistantMessage(element, content) {
                // Check if this is an assistant message with content
                const messageDiv = element.closest('.message.assistant-message');
                if (!messageDiv || !content || !content.trim()) {
                    return;
                }
                
                // Avoid tracking empty or very short messages (likely intermediate streaming states)
                if (content.trim().length < 10) {
                    return;
                }
                
                // Skip tracking system messages
                const systemMessages = [
                    "Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.",
                    "Successfully connected to Revenue Opportunities! You can now ask me questions about your data.",
                    "Sorry, I encountered an error: Rate limited. Please wait before trying again."
                ];
                
                if (systemMessages.some(msg => content.includes(msg))) {
                    return;
                }
                
                // Check if we already have this message in our history
                const lastMessage = this.currentChatMessages[this.currentChatMessages.length - 1];
                if (lastMessage && lastMessage.role === 'assistant') {
                    // Update the existing assistant message
                    lastMessage.content = content;
                    lastMessage.timestamp = Date.now();
                } else {
                    // Add new assistant message
                    const messageData = {
                        role: 'assistant',
                        content: content,
                        timestamp: Date.now()
                    };
                    this.currentChatMessages.push(messageData);
                    
                    // Check if we've reached the message limit and show notification
                    this.checkMessageLimitAndNotify();
                }
                
                // Save to history when we have both user and assistant messages
                if (this.currentChatMessages.length >= 2) {
                    this.saveChatToHistory();
                }
            }
            
            handleToolCallTransitions(element) {
                // Find loading states and completed tool calls
                const completedToolCalls = element.querySelectorAll('.tool-call-block:not(.tool-call-loading-bar)');
                const loadingBars = element.querySelectorAll('.tool-call-loading-bar');
                
                // More selective removal of loading bars
                // Only remove loading bars that appear BEFORE completed tool calls in the content
                if (completedToolCalls.length > 0 && loadingBars.length > 0) {
                    loadingBars.forEach(loadingBar => {
                        // Check if this loading bar is positioned before any completed tool call
                        const loadingBarPosition = Array.from(element.children).indexOf(loadingBar);
                        
                        let shouldRemove = false;
                        completedToolCalls.forEach(completedCall => {
                            const completedPosition = Array.from(element.children).indexOf(completedCall);
                            
                            // If loading bar comes before a completed call and is close to it, remove it
                            if (loadingBarPosition !== -1 && completedPosition !== -1 && 
                                loadingBarPosition < completedPosition && 
                                (completedPosition - loadingBarPosition) <= 3) {
                                shouldRemove = true;
                            }
                        });
                        
                        // Also remove if we have clear evidence this loading bar was replaced
                        if (!shouldRemove) {
                            // Check if there's a completed tool call immediately after this loading bar
                            const nextSibling = loadingBar.nextElementSibling;
                            if (nextSibling && nextSibling.classList.contains('tool-call-block') && 
                                !nextSibling.classList.contains('tool-call-loading-bar')) {
                                shouldRemove = true;
                            }
                        }
                        
                        if (shouldRemove) {
                            console.log('Removing loading bar:', loadingBar.id);
                            loadingBar.remove();
                        }
                    });
                }
            }
            
            scrollStreamingContent() {
                // Find all streaming content containers and scroll them to bottom
                const streamingContainers = document.querySelectorAll('.dax-streaming-content');
                streamingContainers.forEach(container => {
                    container.scrollTop = container.scrollHeight;
                });
            }
            
            containsFormatting(content) {
                // Check for common markdown/HTML patterns
                const patterns = [
                    /\*\*.*?\*\*/,     // Bold markdown
                    /\*.*?\*/,         // Italic markdown  
                    /`.*?`/,           // Code markdown
                    /```[\s\S]*?```/,  // Code blocks
                    /#{1,6}\s/,        // Headers
                    /<[^>]+>/,         // HTML tags
                    /\[.*?\]\(.*?\)/,  // Links
                    /^\s*[-*+]\s/m,    // Lists
                    /^\s*\d+\.\s/m,    // Numbered lists
                    /<function>/i,     // Tool call start markers
                    /<\/function>/i    // Tool call end markers
                ];
                
                const hasFormatting = patterns.some(pattern => pattern.test(content));
                
                // Special handling for tool calls - always process as formatted
                if (content.includes('<function>')) {
                    return true;
                }
                
                return hasFormatting;
            }
            
            parseMarkdown(content) {
                // Simple markdown parser - you may want to use a proper library like marked.js
                let html = content;
                
                // First, check for and process LLM function calls
                html = this.processLLMFunctions(html);
                
                return this.parseMarkdownWithoutFunctions(html);
            }
            
            parseMarkdownWithoutFunctions(content) {
                // Parse markdown without processing function calls (to avoid recursion)
                let html = content;
                
                // Protect DAX code from markdown processing by temporarily replacing it
                const daxCodeBlocks = [];
                const daxBlockRegex = /<pre class="dax-code">([\s\S]*?)<\/pre>/g;
                html = html.replace(daxBlockRegex, (match) => {
                    const placeholder = `__DAX_CODE_BLOCK_${daxCodeBlocks.length}__`;
                    daxCodeBlocks.push(match);
                    return placeholder;
                });
                
                // Convert markdown to HTML
                html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');
                html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
                html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
                
                // More selective italic conversion - avoid matching DAX-like patterns
                // Only match single asterisks with word boundaries and avoid matching minus signs
                html = html.replace(/(?<!\w)\*([^*\n]+?)\*(?!\w)/g, (match, p1) => {
                    // Skip if the content looks like DAX (contains =, parentheses, brackets, etc.)
                    if (/[=()[\],-]/.test(p1) || /\b(SUM|COUNT|CALCULATE|DIVIDE|FILTER|ALL)\b/i.test(p1)) {
                        return match; // Return original, don't convert to italic
                    }
                    return `<em>${p1}</em>`;
                });
                
                html = html.replace(/^#{6}\s(.+)$/gm, '<h6>$1</h6>');
                html = html.replace(/^#{5}\s(.+)$/gm, '<h5>$1</h5>');
                html = html.replace(/^#{4}\s(.+)$/gm, '<h4>$1</h4>');
                html = html.replace(/^#{3}\s(.+)$/gm, '<h3>$1</h3>');
                html = html.replace(/^#{2}\s(.+)$/gm, '<h2>$1</h2>');
                html = html.replace(/^#{1}\s(.+)$/gm, '<h1>$1</h1>');
                html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
                
                // Restore protected DAX code blocks
                daxCodeBlocks.forEach((block, index) => {
                    html = html.replace(`__DAX_CODE_BLOCK_${index}__`, block);
                });
                
                // Convert line breaks to HTML
                html = html.replace(/\n/g, '<br>');
                
                // Basic HTML sanitization (you may want to use a proper library like DOMPurify)
                html = this.sanitizeHtml(html);
                
                return html;
            }
            
            processLLMFunctions(content) {
                let workingContent = content;
                let searchStart = 0;
                let hasIncompleteFunction = false;
                
                // Process function tags sequentially as they appear
                while (true) {
                    // Find next <function> tag starting from where we left off
                    const functionStart = workingContent.indexOf('<function>', searchStart);
                    if (functionStart === -1) break; // No more function tags
                    
                    // Look for matching </function> tag
                    const functionEnd = workingContent.indexOf('</function>', functionStart);
                    
                    if (functionEnd !== -1) {
                        // Complete function call - process it
                        const functionTag = workingContent.substring(functionStart, functionEnd + '</function>'.length);
                        const jsonContent = workingContent.substring(functionStart + '<function>'.length, functionEnd).trim();
                        
                        try {
                            // Clean JSON content
                            let cleanJson = jsonContent;
                            if (cleanJson.startsWith('```json') && cleanJson.endsWith('```')) {
                                cleanJson = cleanJson.slice(7, -3).trim();
                            } else if (cleanJson.startsWith('```') && cleanJson.endsWith('```')) {
                                cleanJson = cleanJson.slice(3, -3).trim();
                            }
                            
                            const functionCall = JSON.parse(cleanJson);
                            
                            if (this.isValidFunctionCall(functionCall)) {
                                const replacement = this.formatLLMFunction(functionCall);
                                workingContent = workingContent.replace(functionTag, replacement);
                                // Continue searching after this replacement
                                searchStart = functionStart + replacement.length;
                            } else {
                                const errorDiv = `<div class="tool-call-error">Invalid function call</div>`;
                                workingContent = workingContent.replace(functionTag, errorDiv);
                                searchStart = functionStart + errorDiv.length;
                            }
                        } catch (e) {
                            const errorDiv = `<div class="tool-call-error">Parse error: ${e.message}</div>`;
                            workingContent = workingContent.replace(functionTag, errorDiv);
                            searchStart = functionStart + errorDiv.length;
                        }
                    } else {
                        // Incomplete function call - show loading state but continue processing
                        const loadingId = 'loading-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        
                        // Look ahead to determine tool type
                        const partialContent = workingContent.substring(functionStart + '<function>'.length, Math.min(workingContent.length, functionStart + '<function>'.length + 100));
                        let type = 'measure';
                        if (partialContent.includes('column_name') || partialContent.includes('calculated_column')) {
                            type = 'column';
                        }
                        
                        // Find where this incomplete function content ends
                        // Look for the next <function> tag or end of content
                        const nextFunctionStart = workingContent.indexOf('<function>', functionStart + '<function>'.length);
                        let incompleteEndPos;
                        
                        if (nextFunctionStart !== -1) {
                            // There's another function after this one
                            incompleteEndPos = nextFunctionStart;
                        } else {
                            // This is the last function, goes to end of content
                            incompleteEndPos = workingContent.length;
                        }
                        
                        // Replace only the incomplete function part with loading state
                        const beforeIncomplete = workingContent.substring(0, functionStart);
                        const afterIncomplete = workingContent.substring(incompleteEndPos);
                        const loadingState = this.createLoadingFunctionCall(loadingId, type);
                        
                        workingContent = beforeIncomplete + loadingState + afterIncomplete;
                        
                        // Continue searching after the loading state we just inserted
                        searchStart = functionStart + loadingState.length;
                        hasIncompleteFunction = true;
                    }
                }
                
                return workingContent;
            }
            
            isValidFunctionCall(functionCall) {
                const validFunctions = ['create_measure', 'edit_measure', 'create_calculated_column', 'edit_calculated_column', 'create_calculated_table', 'edit_calculated_table'];
                
                // More lenient validation - check basic structure exists
                if (!functionCall || !functionCall.name) {
                    console.log('Invalid: Missing functionCall or name property');
                    return false;
                }
                
                // Check if it's a valid function name
                if (!validFunctions.includes(functionCall.name)) {
                    console.log(`Invalid: Function name "${functionCall.name}" not in valid functions:`, validFunctions);
                    return false;
                }
                
                // Check if parameters exist (can be empty object)
                if (!functionCall.hasOwnProperty('parameters')) {
                    return false;
                }
                
                return true;
            }
            
            createLoadingFunctionCall(loadingId, type = 'measure') {
                // Make sure the loading bar has proper styling and is visible
                // Include inline styles as fallback in case CSS doesn't load
                return `<div class="tool-call-loading-bar" id="${loadingId}" style="
                    display: block; 
                    margin: 8px 0; 
                    height: 40px; 
                    background: #2563eb; 
                    border: 2px solid rgba(255, 255, 255, 0.4); 
                    border-radius: 20px; 
                    position: relative;
                    overflow: hidden;
                ">
                    <div class="loading-bar-content" style="
                        position: absolute; 
                        top: 0; left: 0; right: 0; bottom: 0; 
                        z-index: 10; 
                        display: flex; 
                        align-items: center; 
                        justify-content: center; 
                        padding: 0 16px;
                    ">
                        <span class="loading-bar-text pulsing-text" style="
                            color: white; 
                            font-size: 14px; 
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                            white-space: nowrap;
                            animation: pulse-side-to-side 2s ease-in-out infinite;
                        ">Generating ${type}...</span>
                    </div>
                    <div class="loading-bar-pulse"></div>
                </div>`;
            }
            

            
            formatLLMFunction(functionCall) {
                const { name, parameters, explanation } = functionCall;
                
                // Get the appropriate name and expression based on function type
                let itemName, itemExpression, headerTitle;
                
                if (name === 'create_calculated_column' || name === 'edit_calculated_column') {
                    itemName = parameters.column_name || 'New Column';
                    itemExpression = parameters.new_dax_expression || '';
                    headerTitle = `Column: ${itemName}`;
                } else if (name === 'create_calculated_table' || name === 'edit_calculated_table') {
                    itemName = parameters.table_name || 'New Table';
                    itemExpression = parameters.table_expression || '';
                    headerTitle = `Table: ${itemName}`;
                } else {
                    itemName = parameters.measure_name || 'New Measure';
                    itemExpression = parameters.dax_expression || parameters.new_dax_expression || '';
                    headerTitle = `Measure: ${itemName}`;
                }
                
                // Generate unique ID for this tool call
                const toolCallId = `toolcall_${++this.toolCallCounter}`;
                
                // Store the ORIGINAL, CLEAN data - no formatting corruption!
                // Use appropriate property names based on function type
                let originalData = {
                    functionCall: functionCall
                };
                
                if (name === 'create_calculated_column' || name === 'edit_calculated_column') {
                    originalData.columnName = itemName.trim();
                    originalData.columnExpression = itemExpression.trim();
                    originalData.tableName = parameters.table_name; // CRITICAL: Store table name for calculated columns!
                } else if (name === 'create_calculated_table' || name === 'edit_calculated_table') {
                    originalData.tableName = parameters.table_name; // Get actual table name from parameters
                    originalData.tableExpression = itemExpression.trim();
                } else {
                    // Measures (create_measure, edit_measure)
                    originalData.measureName = itemName.trim();
                    originalData.measureExpression = itemExpression.trim();
                }
                
                this.originalToolCallData.set(toolCallId, originalData);
                
                // Create the full DAX definition for display formatting only
                const fullDaxDefinition = `${itemName} = ${itemExpression}`;
                const formattedDax = this.formatDaxCode(fullDaxDefinition);
                
                // Create a minimal tool call block like Cursor
                let html = `<div class="tool-call-block">`;
                html += `<div class="tool-call-header">`;
                html += `<div class="tool-call-title">${headerTitle}</div>`;
                
                // Use data attribute to reference stored clean data - NO MORE ONCLICK CORRUPTION!
                html += `<button class="copy-dax-btn" data-tool-call-id="${toolCallId}" onclick="app.addToPowerBIFromToolCall('${toolCallId}', this)" title="Add to Power BI">Add to Power BI</button>`;
                html += `</div>`;
                
                // Add explanation if provided
                if (explanation) {
                    html += `<div class="tool-call-explanation" style="padding: 12px; background: #21262d; border-bottom: 1px solid #30363d; font-size: 13px; color: #8b949e; font-style: italic;">${explanation}</div>`;
                }
                
                // DAX code block with measure name = expression
                html += `<div class="tool-call-content">`;
                html += `<div class="dax-code-block">`;
                html += `<pre class="dax-code">${formattedDax}</pre>`;
                html += `</div>`;
                html += `</div></div>`;
                
                return html;
            }
            

            
            formatDaxCode(daxCode) {
                // Apply basic DAX syntax highlighting
                let formatted = daxCode;
                
                // First, handle measure/column definition format (Name = Expression) - this works!
                const measureDefRegex = /^([^=]+)\s*=\s*(.+)$/s;
                const measureMatch = formatted.match(measureDefRegex);
                
                let measureName = '';
                let expression = formatted;
                
                if (measureMatch) {
                    measureName = measureMatch[1].trim();
                    expression = measureMatch[2].trim();
                }
                
                // DAX Functions (using a subset of common functions)
                const daxFunctions = [
                    'SUM', 'SUMX', 'COUNT', 'COUNTX', 'AVERAGE', 'AVERAGEX',
                    'MIN', 'MAX', 'CALCULATE', 'CALCULATETABLE', 'FILTER', 'ALL',
                    'DISTINCTCOUNT', 'VALUES', 'RELATED', 'RELATEDTABLE', 'USERELATIONSHIP',
                    'IF', 'SWITCH', 'AND', 'OR', 'NOT', 'BLANK', 'ISBLANK',
                    'YEAR', 'MONTH', 'DAY', 'DATE', 'TODAY', 'NOW', 'DATEDIFF',
                    'CONCATENATE', 'LEFT', 'RIGHT', 'MID', 'LEN', 'TRIM',
                    'DIVIDE', 'RANKX', 'TOPN', 'EARLIER', 'ALLEXCEPT', 'SAMEPERIODLASTYEAR'
                ];
                
                // Keywords
                const daxKeywords = ['VAR', 'RETURN', 'EVALUATE', 'ORDER BY', 'ASC', 'DESC'];
                
                // Apply syntax highlighting to the expression part
                // IMPORTANT: Preserve newlines during syntax highlighting by using placeholders
                
                // First, replace all newlines with a placeholder to preserve them during syntax highlighting
                const NEWLINE_PLACEHOLDER = '__NEWLINE_PLACEHOLDER__';
                expression = expression.replace(/\n/g, NEWLINE_PLACEHOLDER);
                
                // IMPORTANT: Do string/number highlighting FIRST before adding HTML spans with quotes
                
                // Highlight strings first (before any HTML with quotes is added)
                expression = expression.replace(/"([^"]*)"/g, '<span class="dax-string">"$1"</span>');
                
                // Highlight numbers first
                expression = expression.replace(/\b\d+\.?\d*\b/g, '<span class="dax-number">$&</span>');
                
                // Highlight table and column references BEFORE functions (so [DATE] doesn't get affected by DATE function highlighting)
                expression = expression.replace(/\b(\w+)\[(\w+)\]/g, '<span class="dax-table">$1</span>[<span class="dax-column">$2</span>]');
                
                // Now do function and keyword highlighting (won't interfere with [column] references above)
                daxFunctions.forEach(func => {
                    const regex = new RegExp(`\\b${func}\\b`, 'gi');
                    expression = expression.replace(regex, `<span class="dax-function">${func}</span>`);
                });
                
                daxKeywords.forEach(keyword => {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    expression = expression.replace(regex, `<span class="dax-keyword">${keyword}</span>`);
                });
                
                // Highlight comments (update regex to work with placeholder)
                expression = expression.replace(new RegExp(`--([^${NEWLINE_PLACEHOLDER}]*)`, 'g'), '<span class="dax-comment">--$1</span>');
                expression = expression.replace(/\/\*[\s\S]*?\*\//g, '<span class="dax-comment">$&</span>');
                
                // Finally, convert newline placeholders back to <br> tags
                expression = expression.replace(new RegExp(NEWLINE_PLACEHOLDER, 'g'), '<br>');
                
                // Build final formatted result the same way that works for measure names
                if (measureMatch) {
                    // Also convert newlines in measure name if present
                    const formattedMeasureName = measureName.replace(/\n/g, '<br>');
                    formatted = `<span class="dax-measure-name">${formattedMeasureName}</span> <span class="dax-operator">=</span><br>${expression}`;
                } else {
                    formatted = expression;
                }
                
                return formatted;
            }
            
            cleanHtmlFromDax(daxString) {
                if (!daxString) return daxString;
                
                console.log('Input to cleanHtmlFromDax:', JSON.stringify(daxString));
                
                // Convert <br> tags back to newlines first
                let cleaned = daxString.replace(/<br\s*\/?>/gi, '\n');
                
                // Remove any other HTML tags that might have been introduced
                // More specific regex: only remove actual HTML tags (must start with letter)
                // This preserves DAX operators like <>, <, > which don't start with letters
                cleaned = cleaned.replace(/<\/?[a-zA-Z][^>]*>/g, '');
                
                // Decode HTML entities that might be present (order matters - ampersands last)
                cleaned = cleaned.replace(/&lt;/g, '<');
                cleaned = cleaned.replace(/&gt;/g, '>');
                cleaned = cleaned.replace(/&quot;/g, '"');
                cleaned = cleaned.replace(/&#39;/g, "'");
                cleaned = cleaned.replace(/&#10;/g, '\n');
                cleaned = cleaned.replace(/&#13;/g, '\r');
                cleaned = cleaned.replace(/&amp;/g, '&');  // Decode ampersands last to avoid double-decoding
                
                // Clean up excessive whitespace but preserve proper structure
                // Replace multiple consecutive newlines with single newlines
                cleaned = cleaned.replace(/\n\s*\n/g, '\n');
                
                // Trim whitespace from start and end
                cleaned = cleaned.trim();
                
                console.log('Output from cleanHtmlFromDax:', JSON.stringify(cleaned));
                
                return cleaned;
            }
            
            escapeForAttribute(str) {
                return str.replace(/&/g, '&amp;')   // Must be first to avoid double-encoding
                         .replace(/</g, '&lt;')     // Encode angle brackets
                         .replace(/>/g, '&gt;')     // Encode angle brackets  
                         .replace(/'/g, '&#39;')
                         .replace(/"/g, '&quot;')
                         .replace(/\n/g, '&#10;')
                         .replace(/\r/g, '&#13;');
            }
            
            // NEW CLEAN METHOD - uses stored original data, no formatting corruption!
            async addToPowerBIFromToolCall(toolCallId, buttonElement) {
                const originalData = this.originalToolCallData.get(toolCallId);
                if (!originalData) {
                    Utils.showToast('Error: Could not find original tool call data', 'error');
                    return;
                }

                const { functionCall } = originalData;
                
                // Store the button reference for later use
                this.currentButton = buttonElement;

                if (!this.isConnected) {
                    Utils.showToast('Please connect to a Power BI model first', 'error');
                    return;
                }

                // Handle different types of tool calls
                switch (functionCall.name) {
                    case 'create_calculated_column':
                    case 'edit_calculated_column':
                        // For calculated columns, use the cleaned data from originalData
                        console.log('Calculated column parameters:', {
                            columnName: originalData.columnName,
                            columnExpression: originalData.columnExpression,
                            tableName: originalData.tableName
                        });
                        await this.addCalculatedColumnToTable(
                            originalData.columnName,
                            originalData.columnExpression,
                            originalData.tableName
                        );
                        break;

                    case 'create_calculated_table':
                    case 'edit_calculated_table':
                        // For calculated tables, use the cleaned data from originalData
                        console.log('Calculated table parameters:', {
                            tableName: originalData.tableName,
                            tableExpression: originalData.tableExpression
                        });
                        await this.addCalculatedTable(
                            originalData.tableName,
                            originalData.tableExpression
                        );
                        break;

                    case 'create_measure':
                    case 'edit_measure':
                        // For measures, show table selection modal
                        this.showTableSelectionModal(
                            originalData.measureName,
                            originalData.measureExpression
                        );
                        break;
                        
                    default:
                        console.warn('Unknown function call type:', functionCall.name);
                        Utils.showToast('Unknown tool call type: ' + functionCall.name, 'error');
                        break;
                }
            }



            // Add new function for calculated tables
            async addCalculatedTable(tableName, tableExpression) {
                try {
                    const button = this.currentButton;
                    if (!button) return;

                    button.textContent = 'Adding...';
                    button.disabled = true;
                    button.style.background = '#1f6feb';

                    const result = await window.electronAPI.addCalculatedTableToPowerBI({
                        connectionId: this.currentConnectionId,
                        tableName: tableName,
                        tableExpression: tableExpression
                    });

                    if (result.success) {
                        button.textContent = 'Added!';
                        button.style.background = '#238636';
                    } else {
                        throw new Error(result.error || 'Failed to add calculated table to Power BI');
                    }
                } catch (error) {
                    this.handleAddError(error);
                }
            }

            // Add helper function for error handling
            handleAddError(error) {
                const button = this.currentButton;
                if (button) {
                    button.textContent = 'Failed';
                    button.style.background = '#ef4444';
                    
                    setTimeout(() => {
                        if (button) {
                            button.textContent = 'Add to Power BI';
                            button.style.background = '#238636';
                            button.disabled = false;
                        }
                    }, 3000);
                }
                
                Utils.showToast(error.message || 'Operation failed', 'error');
            }

            // LEGACY METHOD - keep for backward compatibility but deprecate
            async addToPowerBI(daxCode, buttonElement) {
                console.log('LEGACY addToPowerBI called - should use addToPowerBIFromToolCall instead');
                console.log('Raw DAX code received:', JSON.stringify(daxCode));
                
                // Decode HTML entities and clean HTML formatting
                let decoded = daxCode.replace(/&lt;/g, '<')      // Decode angle brackets
                                    .replace(/&gt;/g, '>')      // Decode angle brackets
                                    .replace(/&#39;/g, "'")
                                    .replace(/&quot;/g, '"')
                                    .replace(/&#10;/g, '\n')
                                    .replace(/&#13;/g, '\r')
                                    .replace(/&amp;/g, '&');    // Decode ampersands last
                
                console.log('After HTML entity decoding:', JSON.stringify(decoded));
                
                // Convert <br> tags back to actual newlines for proper DAX syntax
                decoded = this.cleanHtmlFromDax(decoded);
                
                console.log('After HTML cleaning:', JSON.stringify(decoded));
                
                if (!this.isConnected) {
                    Utils.showToast('Please connect to a Power BI model first', 'error');
                    return;
                }
                
                // Store the button reference for later use
                this.currentButton = buttonElement;
                
                // Parse the DAX code to extract measure name and expression
                // Updated regex to be more flexible with whitespace and multiline formulas
                const measureMatch = decoded.match(/^\s*([^=\n\r]+?)\s*=\s*(.+)\s*$/s);
                console.log('Regex match result:', measureMatch);
                
                if (!measureMatch) {
                    console.log('Failed to match DAX format. Decoded string:', JSON.stringify(decoded));
                    
                    // Try a more lenient approach - look for any equals sign
                    const fallbackMatch = decoded.match(/^\s*(.+?)\s*=\s*([\s\S]+)\s*$/);
                    if (fallbackMatch) {
                        console.log('Fallback regex matched:', fallbackMatch);
                        // Use fallback match
                        const measureName = fallbackMatch[1].trim();
                        const measureExpression = fallbackMatch[2].trim();
                        this.showTableSelectionModal(measureName, measureExpression);
                        return;
                    }
                    
                    Utils.showToast('Invalid DAX format. Expected: MeasureName = Expression', 'error');
                    return;
                }
                
                const measureName = measureMatch[1].trim();
                const measureExpression = measureMatch[2].trim();
                
                // Always show table selection popup
                this.showTableSelectionModal(measureName, measureExpression);
            }
            
            async addMeasureToTable(measureName, measureExpression, tableName) {
                try {
                    // Use stored button reference
                    const button = this.currentButton;
                    if (!button) {
                        // No button reference found
                        return;
                    }
                    
                    const originalText = button.textContent;
                    button.textContent = 'Adding...';
                    button.disabled = true;
                    button.style.background = '#1f6feb';
                    
                    // Call backend to add measure to Power BI model
                    
                    const result = await window.electronAPI.addMeasureToPowerBI({
                        connectionId: this.currentConnectionId,
                        measureName: measureName,
                        measureExpression: measureExpression,
                        tableName: tableName
                    });
                    
                    if (result.success) {
                        // Show success feedback
                        button.textContent = 'Added!';
                        button.style.background = '#238636';
                        
                        // Schedule metadata refresh after 3 seconds to ensure Power BI model is updated
                        setTimeout(async () => {
                            try {
                                await this.loadMetadata();
                                console.log('Metadata refreshed after measure addition');
                            } catch (error) {
                                console.warn('Failed to refresh metadata after measure addition:', error);
                            }
                        }, 3000);
                    } else {
                        throw new Error(result.error || 'Failed to add measure to Power BI');
                    }
                } catch (error) {
                    // Failed to add measure to Power BI
                    
                    // Show error feedback
                    const button = this.currentButton;
                    if (button) {
                        button.textContent = 'Failed';
                        button.style.background = '#ef4444';
                        
                        // Reset button after delay only on error
                        setTimeout(() => {
                            if (button) {
                                button.textContent = 'Add to Power BI';
                                button.style.background = '#238636';
                                button.disabled = false;
                            }
                        }, 3000);
                    }
                    
                    // Show error message
                    Utils.showToast(`Failed to add measure to Power BI: ${error.message}`, 'error');
                } finally {
                    // Clear the current button reference
                    this.currentButton = null;
                }
            }
            
            showTableSelectionModal(measureName, measureExpression) {
                // Get available tables (exclude hidden tables)
                const availableTables = this.metadata.tables?.filter(table => !table.isHidden) || [];
                
                if (availableTables.length === 0) {
                    Utils.showToast('No available tables found in the model', 'error');
                    return;
                }
                
                // Get button position for dropdown positioning
                const buttonRect = this.currentButton.getBoundingClientRect();
                
                // Calculate dropdown dimensions
                const dropdownWidth = 320;
                const dropdownMaxHeight = 400;
                const padding = 8;
                
                // Calculate available space above and below the button
                const spaceBelow = window.innerHeight - buttonRect.bottom - padding;
                const spaceAbove = buttonRect.top - padding;
                
                // Determine if dropdown should open upward or downward
                let topPosition;
                if (spaceBelow >= dropdownMaxHeight || spaceBelow >= spaceAbove) {
                    // Open downward (default behavior)
                    topPosition = buttonRect.bottom + padding;
                } else {
                    // Open upward
                    topPosition = buttonRect.top - dropdownMaxHeight - padding;
                }
                
                // Ensure dropdown doesn't go off the left or right edge
                const leftPosition = Math.max(padding, Math.min(buttonRect.left, window.innerWidth - dropdownWidth - padding));
                
                // Create dropdown HTML positioned near the button
                const dropdownHtml = `
                    <div class="table-selection-dropdown" id="tableSelectionModal" style="
                        position: fixed;
                        top: ${topPosition}px;
                        left: ${leftPosition}px;
                        background: #161b22;
                        border: 1px solid #30363d;
                        border-radius: 8px;
                        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
                        z-index: 1000;
                        width: ${dropdownWidth}px;
                        max-height: ${dropdownMaxHeight}px;
                        overflow: hidden;
                    ">
                        <div style="padding: 16px; border-bottom: 1px solid #30363d;">
                            <div style="font-weight: 600; color: #f0f6fc; margin-bottom: 8px;">Select Table for Measure</div>
                            <div style="color: #c9d1d9; font-size: 14px;">
                                Add "<strong>${measureName}</strong>" to:
                            </div>
                        </div>
                        
                        <div style="padding: 12px;">
                            <input 
                                type="text" 
                                id="tableSearchInput" 
                                placeholder="Search tables..." 
                                style="width: 100%; padding: 8px 12px; border: 1px solid #30363d; border-radius: 6px; font-size: 14px; margin-bottom: 8px; background: #21262d; color: #c9d1d9;"
                                oninput="app.filterTableList()"
                            />
                        </div>
                        
                        <div class="table-list" id="tableList" style="max-height: 250px; overflow-y: auto;">
                            ${availableTables.map(table => `
                                <div class="table-option" data-table-name="${table.name}" onclick="app.selectTable('${table.name}')" style="
                                    padding: 12px 16px; 
                                    border-bottom: 1px solid #30363d; 
                                    cursor: pointer; 
                                    transition: background 0.2s;
                                    display: flex;
                                    justify-content: space-between;
                                    align-items: center;
                                " onmouseover="this.style.background='#30363d'" onmouseout="this.style.background='transparent'">
                                    <div>
                                        <div style="font-weight: 500; color: #f0f6fc; font-size: 14px;">${table.name}</div>
                                        ${table.description ? `<div style="color: #8b949e; font-size: 12px; margin-top: 2px;">${table.description}</div>` : ''}
                                    </div>
                                    <div style="color: #7d8590; font-size: 12px;">
                                        ${table.measures?.length || 0} measures
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="padding: 12px; border-top: 1px solid #30363d;">
                            <button onclick="app.closeTableSelectionModal()" style="
                                width: 100%;
                                padding: 8px;
                                background: #21262d;
                                border: 1px solid #30363d;
                                border-radius: 6px;
                                color: #c9d1d9;
                                font-size: 14px;
                                cursor: pointer;
                            " onmouseover="this.style.background='#30363d'" onmouseout="this.style.background='#21262d'">Cancel</button>
                        </div>
                    </div>
                `;
                
                // Add backdrop
                const backdropHtml = `
                    <div class="dropdown-backdrop" id="dropdownBackdrop" style="
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: transparent;
                        z-index: 999;
                    " onclick="app.closeTableSelectionModal()"></div>
                `;
                
                // Add both to DOM
                document.body.insertAdjacentHTML('beforeend', backdropHtml);
                document.body.insertAdjacentHTML('beforeend', dropdownHtml);
                
                // Store measure info for later use
                this.pendingMeasure = { measureName, measureExpression };
                
                // Focus on search input
                setTimeout(() => {
                    document.getElementById('tableSearchInput').focus();
                }, 100);
            }
            
            filterTableList() {
                const searchTerm = document.getElementById('tableSearchInput').value.toLowerCase();
                const tableOptions = document.querySelectorAll('.table-option');
                
                tableOptions.forEach(option => {
                    const tableName = option.dataset.tableName.toLowerCase();
                    const description = option.textContent.toLowerCase();
                    
                    if (tableName.includes(searchTerm) || description.includes(searchTerm)) {
                        option.style.display = 'flex';
                    } else {
                        option.style.display = 'none';
                    }
                });
            }
            
            selectTable(tableName) {
                if (this.pendingMeasure) {
                    // Extract the values before closing the modal (which clears pendingMeasure)
                    const measureName = this.pendingMeasure.measureName;
                    const measureExpression = this.pendingMeasure.measureExpression;
                    
                    this.closeTableSelectionModal();
                    this.addMeasureToTable(measureName, measureExpression, tableName);
                }
            }
            
            closeTableSelectionModal() {
                const modal = document.getElementById('tableSelectionModal');
                const backdrop = document.getElementById('dropdownBackdrop');
                if (modal) {
                    modal.remove();
                }
                if (backdrop) {
                    backdrop.remove();
                }
                this.pendingMeasure = null;
            }
            
            sanitizeHtml(html) {
                // Basic HTML sanitization - allows safe tags only
                const allowedTags = ['p', 'br', 'strong', 'em', 'code', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'a', 'blockquote', 'div', 'span', 'button'];
                const allowedAttributes = ['href', 'target', 'class', 'onclick'];
                
                // Simple sanitization - in production, use DOMPurify
                const div = document.createElement('div');
                div.innerHTML = html;
                
                const walker = document.createTreeWalker(
                    div,
                    NodeFilter.SHOW_ELEMENT,
                    null,
                    false
                );
                
                const nodesToRemove = [];
                let node;
                
                while (node = walker.nextNode()) {
                    if (!allowedTags.includes(node.tagName.toLowerCase())) {
                        nodesToRemove.push(node);
                    } else {
                        // Remove disallowed attributes
                        const attributes = Array.from(node.attributes);
                        attributes.forEach(attr => {
                            if (!allowedAttributes.includes(attr.name.toLowerCase())) {
                                node.removeAttribute(attr.name);
                            }
                        });
                    }
                }
                
                nodesToRemove.forEach(node => {
                    node.parentNode?.removeChild(node);
                });
                
                const result = div.innerHTML;
                return result;
            }
            
            addThinkingIndicator() {
                const thinkingId = 'thinking-' + Date.now();
                const messagesContainer = document.getElementById('chatMessages');
                const thinkingDiv = document.createElement('div');
                thinkingDiv.id = thinkingId;
                thinkingDiv.className = 'message assistant-message thinking';
                
                thinkingDiv.innerHTML = `
                    <div class="message-avatar"></div>
                    <div class="message-content">
                        <div class="message-text">
                            <div class="thinking-dots">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                        </div>
                    </div>
                `;
                
                messagesContainer.appendChild(thinkingDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                return thinkingId;
            }
            
            removeThinkingIndicator(thinkingId) {
                const thinkingDiv = document.getElementById(thinkingId);
                if (thinkingDiv) {
                    thinkingDiv.remove();
                }
            }
            
            autoResizeTextarea(textarea) {
                // Reset height to get accurate scrollHeight
                textarea.style.height = 'auto';
                
                // Calculate new height based on content
                const newHeight = Math.min(
                    Math.max(textarea.scrollHeight, 44), // minimum height of 44px
                    120 // maximum height of 120px
                );
                
                // Set the new height
                textarea.style.height = newHeight + 'px';
            }
            
            // Debug helper function - call this from browser console to test tool call rendering
            testToolCallRendering() {
                console.log('Testing tool call rendering...');
                
                // Test loading state
                const testElement = document.createElement('div');
                testElement.innerHTML = this.createLoadingFunctionCall('test-123', 'measure');
                document.body.appendChild(testElement);
                
                setTimeout(() => {
                    console.log('Removing test element');
                    testElement.remove();
                }, 3000);
                
                // Test complete tool call
                const testFunctionCall = {
                    name: 'create_measure',
                    parameters: {
                        measure_name: 'Test Measure',
                        dax_expression: 'SUM(Sales[Amount])',
                        explanation: 'This is a test measure'
                    }
                };
                
                const testElement2 = document.createElement('div');
                testElement2.innerHTML = this.formatLLMFunction(testFunctionCall);
                document.body.appendChild(testElement2);
                
                setTimeout(() => {
                    console.log('Removing test tool call');
                    testElement2.remove();
                }, 5000);
            }
            
            // Test function call validation specifically
            testFunctionValidation() {
                console.log('Testing function call validation...');
                
                // Test valid function call
                const validCall = {
                    name: 'create_measure',
                    parameters: {
                        measure_name: 'Test Measure',
                        dax_expression: 'SUM(Sales[Amount])',
                        explanation: 'Test explanation'
                    }
                };
                
                console.log('Valid call result:', this.isValidFunctionCall(validCall));
                
                // Test invalid function call (wrong name)
                const invalidNameCall = {
                    name: 'invalid_function',
                    parameters: {
                        measure_name: 'Test Measure'
                    }
                };
                
                console.log('Invalid name call result:', this.isValidFunctionCall(invalidNameCall));
                
                // Test missing parameters
                const missingParamsCall = {
                    name: 'create_measure'
                };
                
                console.log('Missing params call result:', this.isValidFunctionCall(missingParamsCall));
            }
            
            // Test streaming behavior: sequential tool call processing
            testMultipleToolCalls() {
                console.log('Testing sequential tool call processing...');
                
                // Add a test message
                const testMessageElement = this.addMessage('assistant', '');
                const messageTextElement = testMessageElement.querySelector('.message-text');
                
                // Step 1: Show incomplete function (should show loading)
                const step1Content = `Here's your first measure:

<function>
{
  "name": "create_measure",
  "parameters": {
    "measure_name": "Total Sales"`;

                console.log('Step 1: First incomplete function (should show loading)');
                this.setMessageContent(messageTextElement, step1Content);
                
                setTimeout(() => {
                    // Step 2: Complete first, start second (first = complete, second = loading)
                    const step2Content = `Here's your first measure:

<function>
{
  "name": "create_measure",
  "parameters": {
    "measure_name": "Total Sales",
    "dax_expression": "SUM(Sales[Amount])",
    "explanation": "Calculates the total sales amount"
  }
}
</function>

And here's a second one:

<function>
{
  "name": "create_measure",
  "parameters": {
    "measure_name": "Average Order"`;

                    console.log('Step 2: First complete, second incomplete (first=result, second=loading)');
                    this.setMessageContent(messageTextElement, step2Content);
                    
                    setTimeout(() => {
                        // Step 3: Both complete (both should show results)
                        const step3Content = `Here's your first measure:

<function>
{
  "name": "create_measure",
  "parameters": {
    "measure_name": "Total Sales",
    "dax_expression": "SUM(Sales[Amount])",
    "explanation": "Calculates the total sales amount"
  }
}
</function>

And here's a second one:

<function>
{
  "name": "create_measure",
  "parameters": {
    "measure_name": "Average Order Value",
    "dax_expression": "DIVIDE(SUM(Sales[Amount]), COUNT(Sales[OrderID]))",
    "explanation": "Calculates the average value per order"
  }
}
</function>

Both measures are now complete!`;

                        console.log('Step 3: Both complete (both should show results)');
                        this.setMessageContent(messageTextElement, step3Content);
                    }, 1500);
                }, 1500);
                
                console.log('Sequential processing test started - watch the loading states!');
            }
            
            // Chat History Management Methods
            initializeChatHistory() {
                // Always start with a new chat when the app initializes
                this.currentChatId = this.generateChatId();
                this.currentChatMessages = [];
                
                // Initialize the chat UI with welcome message
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = `
                    <div class="message assistant-message">
                        <div class="message-avatar"></div>
                        <div class="message-content">
                            <div class="message-text">
                                Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.
                            </div>
                        </div>
                    </div>
                `;
                
                // Load chat history for the sidebar
                this.loadChatHistory();
            }
            
            generateChatId() {
                return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            getCurrentChatTitle() {
                if (this.currentChatMessages.length === 0) {
                    return 'New Chat';
                }
                
                // Find the first user message to use as title
                const firstUserMessage = this.currentChatMessages.find(msg => msg.role === 'user');
                if (firstUserMessage && firstUserMessage.content) {
                    // Extract plain text if there's HTML content
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = firstUserMessage.content;
                    const plainText = tempDiv.textContent || tempDiv.innerText || firstUserMessage.content;
                    
                    // Truncate to reasonable length
                    return plainText.substring(0, 50) + (plainText.length > 50 ? '...' : '');
                }
                
                return 'New Chat';
            }
            
            getChatHistoryFromStorage() {
                try {
                    const stored = localStorage.getItem(this.chatHistoryKey);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('Error loading chat history from storage:', error);
                    return [];
                }
            }
            
            saveChatToHistory() {
                try {
                    if (!this.currentChatId || this.currentChatMessages.length === 0) {
                        console.log('Skipping save - no chat ID or messages');
                        return;
                    }
                    
                    const chatHistory = this.getChatHistoryFromStorage();
                    const chatData = {
                        id: this.currentChatId,
                        title: this.getCurrentChatTitle(),
                        messages: this.currentChatMessages,
                        lastModified: Date.now(),
                        createdAt: this.currentChatMessages[0]?.timestamp || Date.now()
                    };
                    
                    // Remove existing chat with same ID if it exists
                    const existingIndex = chatHistory.findIndex(chat => chat.id === this.currentChatId);
                    if (existingIndex !== -1) {
                        chatHistory.splice(existingIndex, 1);
                    }
                    
                    // Add to beginning of array (most recent first)
                    chatHistory.unshift(chatData);
                    
                    // Keep only the last 50 chats to prevent storage bloat
                    if (chatHistory.length > 50) {
                        chatHistory.splice(50);
                    }
                    
                    localStorage.setItem(this.chatHistoryKey, JSON.stringify(chatHistory));
                } catch (error) {
                    console.warn('Error saving chat history:', error);
                }
            }
            
            loadChatHistory() {
                const chatHistory = this.getChatHistoryFromStorage();
                const chatHistoryList = document.getElementById('chatHistoryList');
                
                if (!chatHistory || chatHistory.length === 0) {
                    chatHistoryList.innerHTML = '<div class="no-chat-history">No chat history yet</div>';
                    return;
                }
                
                chatHistoryList.innerHTML = chatHistory.map(chat => {
                    const isCurrentChat = chat.id === this.currentChatId;
                    const date = new Date(chat.lastModified || chat.createdAt).toLocaleDateString();
                    
                    // Get preview from last message, extract plain text if needed
                    let preview = 'No messages yet';
                    if (chat.messages.length > 1) {
                        const lastMessage = chat.messages[chat.messages.length - 1];
                        if (lastMessage?.content) {
                            // Extract plain text from HTML content for preview
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = lastMessage.content;
                            const plainText = tempDiv.textContent || tempDiv.innerText || lastMessage.content;
                            preview = plainText.substring(0, 60) + (plainText.length > 60 ? '...' : '');
                        }
                    }
                    
                    return `
                        <button class="chat-history-item ${isCurrentChat ? 'current-chat' : ''}" 
                                onclick="app.loadChat('${chat.id}')" 
                                data-chat-id="${chat.id}">
                            <div class="chat-history-item-title">${chat.title}</div>
                            <div class="chat-history-item-preview">${preview}</div>
                            <div class="chat-history-item-date">${date}</div>
                        </button>
                    `;
                }).join('');
            }
            
            startNewChat() {
                // Save current chat before starting new one
                if (this.currentChatMessages.length > 0) {
                    this.saveChatToHistory();
                }
                
                // Create new chat
                this.currentChatId = this.generateChatId();
                this.currentChatMessages = [];
                
                // Clear the chat messages UI
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = `
                    <div class="message assistant-message">
                        <div class="message-avatar"></div>
                        <div class="message-content">
                            <div class="message-text">
                                Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.
                            </div>
                        </div>
                    </div>
                `;
            }
            
            loadChat(chatId) {
                // Save current chat before switching
                if (this.currentChatMessages.length > 0) {
                    this.saveChatToHistory();
                }
                
                const chatHistory = this.getChatHistoryFromStorage();
                const selectedChat = chatHistory.find(chat => chat.id === chatId);
                
                if (!selectedChat) {
                    console.warn('Chat not found:', chatId);
                    return;
                }
                
                // Load the selected chat
                this.currentChatId = selectedChat.id;
                this.currentChatMessages = selectedChat.messages || [];
                
                // Clear and rebuild the chat UI
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = '';
                
                // Add initial welcome message if no messages
                if (this.currentChatMessages.length === 0) {
                    chatMessages.innerHTML = `
                        <div class="message assistant-message">
                            <div class="message-avatar"></div>
                            <div class="message-content">
                                <div class="message-text">
                                    Welcome! I'm Analytics Pilot. Connect to your Power BI model to get started with data analysis.
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Rebuild messages from history
                    // Temporarily disable tracking while rebuilding to avoid duplicates
                    const tempMessages = [...this.currentChatMessages];
                    this.currentChatMessages = [];
                    
                    tempMessages.forEach(message => {
                        const messageElement = this.addMessage(message.role === 'user' ? 'user' : 'assistant', message.content);
                        // For assistant messages, make sure they're properly formatted
                        if (message.role === 'assistant') {
                            const messageTextElement = messageElement.querySelector('.message-text');
                            this.setMessageContent(messageTextElement, message.content);
                        }
                    });
                    
                    // Restore the original messages array
                    this.currentChatMessages = tempMessages;
                }
                
                // Scroll to bottom
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            
        }
        
        // Make test functions available globally for debugging
        window.testToolCalls = function() {
            if (app && app.testToolCallRendering) {
                app.testToolCallRendering();
            } else {
                console.log('App not initialized yet');
            }
        };
        
        window.testValidation = function() {
            if (app && app.testFunctionValidation) {
                app.testFunctionValidation();
            } else {
                console.log('App not initialized yet');
            }
        };
        
        window.testMultiple = function() {
            if (app && app.testMultipleToolCalls) {
                app.testMultipleToolCalls();
            } else {
                console.log('App not initialized yet');
            }
        };
        
        // Update notification management
        const UpdateNotification = {
            notification: null,
            currentUpdateInfo: null,
            
            init() {
                this.createNotificationElement();
                this.setupEventListeners();
            },
            
            createNotificationElement() {
                this.notification = document.createElement('div');
                this.notification.className = 'update-notification';
                this.notification.innerHTML = `
                    <div class="update-notification-header">
                        <h3 class="update-notification-title">
                            <svg class="update-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 8L12 17l-7-7"></path>
                                <path d="M21 12.5a9 9 0 1 1-6.3-8.5"></path>
                            </svg>
                            Update Available
                        </h3>
                        <button class="update-notification-close" id="updateNotificationClose">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    <div class="update-notification-content">
                        <div class="update-notification-version" id="updateNotificationVersion"></div>
                        <div class="update-notification-description" id="updateNotificationDescription"></div>
                    </div>
                    <div class="update-notification-actions">
                        <button class="update-notification-btn secondary" id="updateNotificationLater">Later</button>
                        <button class="update-notification-btn primary" id="updateNotificationInstall">Install</button>
                    </div>
                `;
                document.body.appendChild(this.notification);
            },
            
            setupEventListeners() {
                // Close button
                document.getElementById('updateNotificationClose').addEventListener('click', () => {
                    this.hide();
                });
                
                // Later button
                document.getElementById('updateNotificationLater').addEventListener('click', () => {
                    this.hide();
                });
                
                // Install button
                document.getElementById('updateNotificationInstall').addEventListener('click', () => {
                    this.installUpdate();
                });
                
                // Listen for update events from main process
                window.electronAPI.onUpdateAvailable((updateInfo) => {
                    this.show(updateInfo);
                });
            },
            
            show(updateInfo) {
                this.currentUpdateInfo = updateInfo;
                
                // Update content
                document.getElementById('updateNotificationVersion').textContent = 
                    `Version ${updateInfo.latestVersion} is available`;
                    
                document.getElementById('updateNotificationDescription').textContent = 
                    updateInfo.releaseNotes || 'Bug fixes and improvements';
                
                // Show notification
                this.notification.classList.add('show');
            },
            
            hide() {
                this.notification.classList.remove('show');
            },
            
            async installUpdate() {
                if (!this.currentUpdateInfo || !this.currentUpdateInfo.downloadUrl) {
                    Utils.showToast('No download URL available', 'error');
                    return;
                }
                
                try {
                    const result = await window.electronAPI.downloadUpdate(this.currentUpdateInfo.downloadUrl);
                    
                    if (result.success) {
                        Utils.showToast('Download started. The update will open in your browser.', 'success');
                        this.hide();
                    } else {
                        Utils.showToast(`Failed to start download: ${result.error}`, 'error');
                    }
                } catch (error) {
                    Utils.showToast(`Error downloading update: ${error.message}`, 'error');
                }
            }
        };
        
        // Initialize update notification when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => UpdateNotification.init());
        } else {
            UpdateNotification.init();
        }

    </script>
</body>
</html> 